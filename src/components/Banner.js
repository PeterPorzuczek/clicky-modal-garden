      "data-component-path": "src/components/Banner.tsx",
      "data-component-line": "35",
      "data-component-file": "Banner.tsx",
      "data-component-name": "div",
      "data-component-content": "%7B%22className%22%3A%22w-full%22%7D",
      className: "w-full",
      children: [
        d.jsxs("div", {
          "data-lov-id": "src/components/Banner.tsx:36:6",
          "data-lov-name": "div",
          "data-component-path": "src/components/Banner.tsx",
          "data-component-line": "36",
          "data-component-file": "Banner.tsx",
          "data-component-name": "div",
          "data-component-content":
            "%7B%22className%22%3A%22bg-%5Bhsl(var(--navy))%5D%20text-white%20p-8%20rounded-lg%20shadow-lg%20cursor-pointer%20hover%3Ashadow-xl%20transition-shadow%20w-full%20max-w-3xl%20mx-auto%20flex%20flex-col%20items-center%20justify-center%22%7D",
          className:
            "bg-[hsl(var(--navy))] text-white p-8 rounded-lg shadow-lg cursor-pointer hover:shadow-xl transition-shadow w-full max-w-3xl mx-auto flex flex-col items-center justify-center",
          onClick: s,
          children: [
            d.jsx("h2", {
              "data-lov-id": "src/components/Banner.tsx:37:8",
              "data-lov-name": "h2",
              "data-component-path": "src/components/Banner.tsx",
              "data-component-line": "37",
              "data-component-file": "Banner.tsx",
              "data-component-name": "h2",
              "data-component-content":
                "%7B%22text%22%3A%22Best%C3%A4ll%20lagning%20%26%20%C3%A5terst%C3%A4llning%22%2C%22className%22%3A%22text-2xl%20md%3Atext-3xl%20font-bold%20mb-3%22%7D",
              className: "text-2xl md:text-3xl font-bold mb-3",
              children: "Beställ lagning & återställning",
            }),
            d.jsx("p", {
              "data-lov-id": "src/components/Banner.tsx:38:8",
              "data-lov-name": "p",
              "data-component-path": "src/components/Banner.tsx",
              "data-component-line": "38",
              "data-component-file": "Banner.tsx",
              "data-component-name": "p",
              "data-component-content":
                "%7B%22text%22%3A%22Som%20icke%20inloggad%20kund%22%2C%22className%22%3A%22text-gray-200%20text-center%22%7D",
              className: "text-gray-200 text-center",
              children: "Som icke inloggad kund",
            }),
          ],
        }),
        d.jsx(yD, {
          "data-lov-id": "src/components/Banner.tsx:41:6",
          "data-lov-name": "Dialog",
          "data-component-path": "src/components/Banner.tsx",
          "data-component-line": "41",
          "data-component-file": "Banner.tsx",
          "data-component-name": "Dialog",
          "data-component-content": "%7B%7D",
          open: a,
          onOpenChange: (i) => {
            n === void 0 && r(i), t && t(i);
          },
          children: d.jsxs(c0, {
            "data-lov-id": "src/components/Banner.tsx:49:8",
            "data-lov-name": "DialogContent",
            "data-component-path": "src/components/Banner.tsx",
            "data-component-line": "49",
            "data-component-file": "Banner.tsx",
            "data-component-name": "DialogContent",
            "data-component-content":
              "%7B%22className%22%3A%22sm%3Amax-w-%5B650px%5D%20p-0%20overflow-hidden%20max-h-%5B90vh%5D%20flex%20flex-col%22%7D",
            className:
              "sm:max-w-[650px] p-0 overflow-hidden max-h-[90vh] flex flex-col",
            children: [
              d.jsx(d0, {
                "data-lov-id": "src/components/Banner.tsx:50:10",
                "data-lov-name": "DialogTitle",
                "data-component-path": "src/components/Banner.tsx",
                "data-component-line": "50",
                "data-component-file": "Banner.tsx",
                "data-component-name": "DialogTitle",
                "data-component-content":
                  "%7B%22text%22%3A%22Best%C3%A4ll%20lagning%20%26%20%C3%A5terst%C3%A4llning%22%2C%22className%22%3A%22sr-only%22%7D",
                className: "sr-only",
                children: "Beställ lagning & återställning",
              }),
              d.jsx(u0, {
                "data-lov-id": "src/components/Banner.tsx:51:10",
                "data-lov-name": "DialogDescription",
                "data-component-path": "src/components/Banner.tsx",
                "data-component-line": "51",
                "data-component-file": "Banner.tsx",
                "data-component-name": "DialogDescription",
                "data-component-content":
                  "%7B%22text%22%3A%22Formul%C3%A4r%20f%C3%B6r%20att%20best%C3%A4lla%20lagning%20och%20%C3%A5terst%C3%A4llning%20av%20arbetskl%C3%A4der%22%2C%22className%22%3A%22sr-only%22%7D",
                className: "sr-only",
                children:
                  "Formulär för att beställa lagning och återställning av arbetskläder",
              }),
              d.jsx("div", {
                "data-lov-id": "src/components/Banner.tsx:54:10",
                "data-lov-name": "div",
                "data-component-path": "src/components/Banner.tsx",
                "data-component-line": "54",
                "data-component-file": "Banner.tsx",
                "data-component-name": "div",
                "data-component-content":
                  "%7B%22className%22%3A%22flex-1%20overflow-auto%22%7D",
                className: "flex-1 overflow-auto",
                children: d.jsx(KE, {
                  "data-lov-id": "src/components/Banner.tsx:55:12",
                  "data-lov-name": "OrderForm",
                  "data-component-path": "src/components/Banner.tsx",
                  "data-component-line": "55",
                  "data-component-file": "Banner.tsx",
                  "data-component-name": "OrderForm",
                  "data-component-content": "%7B%7D",
                  prefilledData: e,
                }),
              }),
              d.jsx(i0, {
                "data-lov-id": "src/components/Banner.tsx:57:10",
                "data-lov-name": "DialogClose",
                "data-component-path": "src/components/Banner.tsx",
                "data-component-line": "57",
                "data-component-file": "Banner.tsx",
                "data-component-name": "DialogClose",
                "data-component-content":
                  "%7B%22className%22%3A%22absolute%20right-4%20top-4%20rounded-sm%20opacity-70%20ring-offset-background%20transition-opacity%20hover%3Aopacity-100%20focus%3Aoutline-none%20focus%3Aring-2%20focus%3Aring-ring%20focus%3Aring-offset-2%20disabled%3Apointer-events-none%20data-%5Bstate%3Dopen%5D%3Abg-accent%20data-%5Bstate%3Dopen%5D%3Atext-muted-foreground%22%7D",
                className:
                  "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground",
              }),
            ],
          }),
        }),
      ],
    });
  },
  QE = {
    customerNumber: "CUS12345",
    companyName: "Demo AB",
    ordererName: "Anna Andersson",
    phone: "070-123 45 67",
    email: "anna.andersson@demo.se",
    billingCompanyName: "Demo AB",
    billingStreet: "Storgatan 1",
    billingZipCode: "12345",
    billingCity: "Stockholm",
    pickupCompanyName: "Demo AB",
    pickupStreet: "Storgatan 1",
    pickupZipCode: "12345",
    pickupCity: "Stockholm",
    usePickupAddressForDelivery: !0,
    deliveryCompanyName: "",
    deliveryStreet: "",
    deliveryZipCode: "",
    deliveryCity: "",
  },
  JE = () => {
    const [e, t] = f.useState(null);
    return {
      prefilledData: e,
      loadCustomerData: () => {
        t(QE);
      },
      clearPrefilledData: () => {
        t(null);
      },
    };
  },
  YE = "modulepreload",
  XE = function (e) {
    return "/" + e;
  },
  hh = {},
  Br = function (t, n, o) {
    let r = Promise.resolve();
    if (n && n.length > 0) {
      document.getElementsByTagName("link");
      const s = document.querySelector("meta[property=csp-nonce]"),
        i =
          (s == null ? void 0 : s.nonce) ||
          (s == null ? void 0 : s.getAttribute("nonce"));
      r = Promise.allSettled(
        n.map((l) => {
          if (((l = XE(l)), l in hh)) return;
          hh[l] = !0;
          const c = l.endsWith(".css"),
            u = c ? '[rel="stylesheet"]' : "";
          if (document.querySelector(`link[href="${l}"]${u}`)) return;
          const m = document.createElement("link");
          if (
            ((m.rel = c ? "stylesheet" : YE),
            c || (m.as = "script"),
            (m.crossOrigin = ""),
            (m.href = l),
            i && m.setAttribute("nonce", i),
            document.head.appendChild(m),
            c)
          )
            return new Promise((p, h) => {
              m.addEventListener("load", p),
                m.addEventListener("error", () =>
                  h(new Error(`Unable to preload CSS for ${l}`)),
                );
            });
        }),
      );
    }
    function a(s) {
      const i = new Event("vite:preloadError", { cancelable: !0 });
      if (((i.payload = s), window.dispatchEvent(i), !i.defaultPrevented))
        throw s;
    }
    return r.then((s) => {
      for (const i of s || []) i.status === "rejected" && a(i.reason);
      return t().catch(a);
    });
  },
  ZE = (e) => {
    let t;
    return (
      e
        ? (t = e)
        : typeof fetch > "u"
          ? (t = (...n) =>
              Br(
                async () => {
                  const { default: o } = await Promise.resolve().then(() => Yr);
                  return { default: o };
                },
                void 0,
              ).then(({ default: o }) => o(...n)))
          : (t = fetch),
      (...n) => t(...n)
    );
  };
class Qm extends Error {
  constructor(t, n = "FunctionsError", o) {
    super(t), (this.name = n), (this.context = o);
  }
}
class eN extends Qm {
  constructor(t) {
    super(
      "Failed to send a request to the Edge Function",
      "FunctionsFetchError",
      t,
    );
  }
}
class tN extends Qm {
  constructor(t) {
    super("Relay Error invoking the Edge Function", "FunctionsRelayError", t);
  }
}
class nN extends Qm {
  constructor(t) {
    super(
      "Edge Function returned a non-2xx status code",
      "FunctionsHttpError",
      t,
    );
  }
}
var ru;
(function (e) {
  (e.Any = "any"),
    (e.ApNortheast1 = "ap-northeast-1"),
    (e.ApNortheast2 = "ap-northeast-2"),
    (e.ApSouth1 = "ap-south-1"),
    (e.ApSoutheast1 = "ap-southeast-1"),
    (e.ApSoutheast2 = "ap-southeast-2"),
    (e.CaCentral1 = "ca-central-1"),
    (e.EuCentral1 = "eu-central-1"),
    (e.EuWest1 = "eu-west-1"),
    (e.EuWest2 = "eu-west-2"),
    (e.EuWest3 = "eu-west-3"),
    (e.SaEast1 = "sa-east-1"),
    (e.UsEast1 = "us-east-1"),
    (e.UsWest1 = "us-west-1"),
    (e.UsWest2 = "us-west-2");
})(ru || (ru = {}));
var oN = function (e, t, n, o) {
  function r(a) {
    return a instanceof n
      ? a
      : new n(function (s) {
          s(a);
        });
  }
  return new (n || (n = Promise))(function (a, s) {
    function i(u) {
      try {
        c(o.next(u));
      } catch (m) {
        s(m);
      }
    }
    function l(u) {
      try {
        c(o.throw(u));
      } catch (m) {
        s(m);
      }
    }
    function c(u) {
      u.done ? a(u.value) : r(u.value).then(i, l);
    }
    c((o = o.apply(e, t || [])).next());
  });
};
class rN {
  constructor(t, { headers: n = {}, customFetch: o, region: r = ru.Any } = {}) {
    (this.url = t), (this.headers = n), (this.region = r), (this.fetch = ZE(o));
  }
  setAuth(t) {
    this.headers.Authorization = `Bearer ${t}`;
  }
  invoke(t, n = {}) {
    var o;
    return oN(this, void 0, void 0, function* () {
      try {
        const { headers: r, method: a, body: s } = n;
        let i = {},
          { region: l } = n;
        l || (l = this.region), l && l !== "any" && (i["x-region"] = l);
        let c;
        s &&
          ((r && !Object.prototype.hasOwnProperty.call(r, "Content-Type")) ||
            !r) &&
          ((typeof Blob < "u" && s instanceof Blob) || s instanceof ArrayBuffer
            ? ((i["Content-Type"] = "application/octet-stream"), (c = s))
            : typeof s == "string"
              ? ((i["Content-Type"] = "text/plain"), (c = s))
              : typeof FormData < "u" && s instanceof FormData
                ? (c = s)
                : ((i["Content-Type"] = "application/json"),
                  (c = JSON.stringify(s))));
        const u = yield this.fetch(`${this.url}/${t}`, {
            method: a || "POST",
            headers: Object.assign(
              Object.assign(Object.assign({}, i), this.headers),
              r,
            ),
            body: c,
          }).catch((g) => {
            throw new eN(g);
          }),
          m = u.headers.get("x-relay-error");
        if (m && m === "true") throw new tN(u);
        if (!u.ok) throw new nN(u);
        let p = (
            (o = u.headers.get("Content-Type")) !== null && o !== void 0
              ? o
              : "text/plain"
          )
            .split(";")[0]
            .trim(),
          h;
        return (
          p === "application/json"
            ? (h = yield u.json())
            : p === "application/octet-stream"
              ? (h = yield u.blob())
              : p === "text/event-stream"
                ? (h = u)
                : p === "multipart/form-data"
                  ? (h = yield u.formData())
                  : (h = yield u.text()),
          { data: h, error: null }
        );
      } catch (r) {
        return { data: null, error: r };
      }
    });
  }
}
var Ze = {},
  Jm = {},
  $l = {},
  ws = {},
  Fl = {},
  Ul = {},
  aN = function () {
    if (typeof self < "u") return self;
    if (typeof window < "u") return window;
    if (typeof global < "u") return global;
    throw new Error("unable to locate global object");
  },
  Lr = aN();
const sN = Lr.fetch,
  Ey = Lr.fetch.bind(Lr),
  Ny = Lr.Headers,
  iN = Lr.Request,
  lN = Lr.Response,
  Yr = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Headers: Ny,
        Request: iN,
        Response: lN,
        default: Ey,
        fetch: sN,
      },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  cN = gS(Yr);
var zl = {};
Object.defineProperty(zl, "__esModule", { value: !0 });
let dN = class extends Error {
  constructor(t) {
    super(t.message),
      (this.name = "PostgrestError"),
      (this.details = t.details),
      (this.hint = t.hint),
      (this.code = t.code);
  }
};
zl.default = dN;
var Oy =
  (Ct && Ct.__importDefault) ||
  function (e) {
    return e && e.__esModule ? e : { default: e };
  };
Object.defineProperty(Ul, "__esModule", { value: !0 });
const uN = Oy(cN),
  mN = Oy(zl);
let pN = class {
  constructor(t) {
    (this.shouldThrowOnError = !1),
      (this.method = t.method),
      (this.url = t.url),
      (this.headers = t.headers),
      (this.schema = t.schema),
      (this.body = t.body),
      (this.shouldThrowOnError = t.shouldThrowOnError),
      (this.signal = t.signal),
      (this.isMaybeSingle = t.isMaybeSingle),
      t.fetch
        ? (this.fetch = t.fetch)
        : typeof fetch > "u"
          ? (this.fetch = uN.default)
          : (this.fetch = fetch);
  }
  throwOnError() {
    return (this.shouldThrowOnError = !0), this;
  }
  setHeader(t, n) {
    return (
      (this.headers = Object.assign({}, this.headers)),
      (this.headers[t] = n),
      this
    );
  }
  then(t, n) {
    this.schema === void 0 ||
      (["GET", "HEAD"].includes(this.method)
        ? (this.headers["Accept-Profile"] = this.schema)
        : (this.headers["Content-Profile"] = this.schema)),
      this.method !== "GET" &&
        this.method !== "HEAD" &&
        (this.headers["Content-Type"] = "application/json");
    const o = this.fetch;
    let r = o(this.url.toString(), {
      method: this.method,
      headers: this.headers,
      body: JSON.stringify(this.body),
      signal: this.signal,
    }).then(async (a) => {
      var s, i, l;
      let c = null,
        u = null,
        m = null,
        p = a.status,
        h = a.statusText;
      if (a.ok) {
        if (this.method !== "HEAD") {
          const y = await a.text();
          y === "" ||
            (this.headers.Accept === "text/csv" ||
            (this.headers.Accept &&
              this.headers.Accept.includes("application/vnd.pgrst.plan+text"))
              ? (u = y)
              : (u = JSON.parse(y)));
        }
        const v =
            (s = this.headers.Prefer) === null || s === void 0
              ? void 0
              : s.match(/count=(exact|planned|estimated)/),
          w =
            (i = a.headers.get("content-range")) === null || i === void 0
              ? void 0
              : i.split("/");
        v && w && w.length > 1 && (m = parseInt(w[1])),
          this.isMaybeSingle &&
            this.method === "GET" &&
            Array.isArray(u) &&
            (u.length > 1
              ? ((c = {
                  code: "PGRST116",
                  details: `Results contain ${u.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                  hint: null,
                  message:
                    "JSON object requested, multiple (or no) rows returned",
                }),
                (u = null),
                (m = null),
                (p = 406),
                (h = "Not Acceptable"))
              : u.length === 1
                ? (u = u[0])
                : (u = null));
      } else {
        const v = await a.text();
        try {
          (c = JSON.parse(v)),
            Array.isArray(c) &&
              a.status === 404 &&
              ((u = []), (c = null), (p = 200), (h = "OK"));
        } catch {
          a.status === 404 && v === ""
            ? ((p = 204), (h = "No Content"))
            : (c = { message: v });
        }
        if (
          (c &&
            this.isMaybeSingle &&
            !((l = c == null ? void 0 : c.details) === null || l === void 0) &&
            l.includes("0 rows") &&
            ((c = null), (p = 200), (h = "OK")),
          c && this.shouldThrowOnError)
        )
          throw new mN.default(c);
      }
      return { error: c, data: u, count: m, status: p, statusText: h };
    });
    return (
      this.shouldThrowOnError ||
        (r = r.catch((a) => {
          var s, i, l;
          return {
            error: {
              message: `${(s = a == null ? void 0 : a.name) !== null && s !== void 0 ? s : "FetchError"}: ${a == null ? void 0 : a.message}`,
              details: `${(i = a == null ? void 0 : a.stack) !== null && i !== void 0 ? i : ""}`,
              hint: "",
              code: `${(l = a == null ? void 0 : a.code) !== null && l !== void 0 ? l : ""}`,
            },
            data: null,
            count: null,
            status: 0,
            statusText: "",
          };
        })),
      r.then(t, n)
    );
  }
  returns() {
    return this;
  }
  overrideTypes() {
    return this;
  }
};
Ul.default = pN;
var fN =
  (Ct && Ct.__importDefault) ||
  function (e) {
    return e && e.__esModule ? e : { default: e };
  };
Object.defineProperty(Fl, "__esModule", { value: !0 });
const hN = fN(Ul);
let vN = class extends hN.default {
  select(t) {
    let n = !1;
    const o = (t ?? "*")
      .split("")
      .map((r) => (/\s/.test(r) && !n ? "" : (r === '"' && (n = !n), r)))
      .join("");
    return (
      this.url.searchParams.set("select", o),
      this.headers.Prefer && (this.headers.Prefer += ","),
      (this.headers.Prefer += "return=representation"),
      this
    );
  }
  order(
    t,
    {
      ascending: n = !0,
      nullsFirst: o,
      foreignTable: r,
      referencedTable: a = r,
    } = {},
  ) {
    const s = a ? `${a}.order` : "order",
      i = this.url.searchParams.get(s);
    return (
      this.url.searchParams.set(
        s,
        `${i ? `${i},` : ""}${t}.${n ? "asc" : "desc"}${o === void 0 ? "" : o ? ".nullsfirst" : ".nullslast"}`,
      ),
      this
    );
  }
  limit(t, { foreignTable: n, referencedTable: o = n } = {}) {
    const r = typeof o > "u" ? "limit" : `${o}.limit`;
    return this.url.searchParams.set(r, `${t}`), this;
  }
  range(t, n, { foreignTable: o, referencedTable: r = o } = {}) {
    const a = typeof r > "u" ? "offset" : `${r}.offset`,
      s = typeof r > "u" ? "limit" : `${r}.limit`;
    return (
      this.url.searchParams.set(a, `${t}`),
      this.url.searchParams.set(s, `${n - t + 1}`),
      this
    );
  }
  abortSignal(t) {
    return (this.signal = t), this;
  }
  single() {
    return (this.headers.Accept = "application/vnd.pgrst.object+json"), this;
  }
  maybeSingle() {
    return (
      this.method === "GET"
        ? (this.headers.Accept = "application/json")
        : (this.headers.Accept = "application/vnd.pgrst.object+json"),
      (this.isMaybeSingle = !0),
      this
    );
  }
  csv() {
    return (this.headers.Accept = "text/csv"), this;
  }
  geojson() {
    return (this.headers.Accept = "application/geo+json"), this;
  }
  explain({
    analyze: t = !1,
    verbose: n = !1,
    settings: o = !1,
    buffers: r = !1,
    wal: a = !1,
    format: s = "text",
  } = {}) {
    var i;
    const l = [
        t ? "analyze" : null,
        n ? "verbose" : null,
        o ? "settings" : null,
        r ? "buffers" : null,
        a ? "wal" : null,
      ]
        .filter(Boolean)
        .join("|"),
      c =
        (i = this.headers.Accept) !== null && i !== void 0
          ? i
          : "application/json";
    return (
      (this.headers.Accept = `application/vnd.pgrst.plan+${s}; for="${c}"; options=${l};`),
      s === "json" ? this : this
    );
  }
  rollback() {
    var t;
    return (
      ((t = this.headers.Prefer) !== null && t !== void 0 ? t : "").trim()
        .length > 0
        ? (this.headers.Prefer += ",tx=rollback")
        : (this.headers.Prefer = "tx=rollback"),
      this
    );
  }
  returns() {
    return this;
  }
};
Fl.default = vN;
var gN =
  (Ct && Ct.__importDefault) ||
  function (e) {
    return e && e.__esModule ? e : { default: e };
  };
Object.defineProperty(ws, "__esModule", { value: !0 });
const xN = gN(Fl);
let yN = class extends xN.default {
  eq(t, n) {
    return this.url.searchParams.append(t, `eq.${n}`), this;
  }
  neq(t, n) {
    return this.url.searchParams.append(t, `neq.${n}`), this;
  }
  gt(t, n) {
    return this.url.searchParams.append(t, `gt.${n}`), this;
  }
  gte(t, n) {
    return this.url.searchParams.append(t, `gte.${n}`), this;
  }
  lt(t, n) {
    return this.url.searchParams.append(t, `lt.${n}`), this;
  }
  lte(t, n) {
    return this.url.searchParams.append(t, `lte.${n}`), this;
  }
  like(t, n) {
    return this.url.searchParams.append(t, `like.${n}`), this;
  }
  likeAllOf(t, n) {
    return this.url.searchParams.append(t, `like(all).{${n.join(",")}}`), this;
  }
  likeAnyOf(t, n) {
    return this.url.searchParams.append(t, `like(any).{${n.join(",")}}`), this;
  }
  ilike(t, n) {
    return this.url.searchParams.append(t, `ilike.${n}`), this;
  }
  ilikeAllOf(t, n) {
    return this.url.searchParams.append(t, `ilike(all).{${n.join(",")}}`), this;
  }
  ilikeAnyOf(t, n) {
    return this.url.searchParams.append(t, `ilike(any).{${n.join(",")}}`), this;
  }
  is(t, n) {
    return this.url.searchParams.append(t, `is.${n}`), this;
  }
  in(t, n) {
    const o = Array.from(new Set(n))
      .map((r) =>
        typeof r == "string" && new RegExp("[,()]").test(r) ? `"${r}"` : `${r}`,
      )
      .join(",");
    return this.url.searchParams.append(t, `in.(${o})`), this;
  }
  contains(t, n) {
    return (
      typeof n == "string"
        ? this.url.searchParams.append(t, `cs.${n}`)
        : Array.isArray(n)
          ? this.url.searchParams.append(t, `cs.{${n.join(",")}}`)
          : this.url.searchParams.append(t, `cs.${JSON.stringify(n)}`),
      this
    );
  }
  containedBy(t, n) {
    return (
      typeof n == "string"
        ? this.url.searchParams.append(t, `cd.${n}`)
        : Array.isArray(n)
          ? this.url.searchParams.append(t, `cd.{${n.join(",")}}`)
          : this.url.searchParams.append(t, `cd.${JSON.stringify(n)}`),
      this
    );
  }
  rangeGt(t, n) {
    return this.url.searchParams.append(t, `sr.${n}`), this;
  }
  rangeGte(t, n) {
    return this.url.searchParams.append(t, `nxl.${n}`), this;
  }
  rangeLt(t, n) {
    return this.url.searchParams.append(t, `sl.${n}`), this;
  }
  rangeLte(t, n) {
    return this.url.searchParams.append(t, `nxr.${n}`), this;
  }
  rangeAdjacent(t, n) {
    return this.url.searchParams.append(t, `adj.${n}`), this;
  }
  overlaps(t, n) {
    return (
      typeof n == "string"
        ? this.url.searchParams.append(t, `ov.${n}`)
        : this.url.searchParams.append(t, `ov.{${n.join(",")}}`),
      this
    );
  }
  textSearch(t, n, { config: o, type: r } = {}) {
    let a = "";
    r === "plain"
      ? (a = "pl")
      : r === "phrase"
        ? (a = "ph")
        : r === "websearch" && (a = "w");
    const s = o === void 0 ? "" : `(${o})`;
    return this.url.searchParams.append(t, `${a}fts${s}.${n}`), this;
  }
  match(t) {
    return (
      Object.entries(t).forEach(([n, o]) => {
        this.url.searchParams.append(n, `eq.${o}`);
      }),
      this
    );
  }
  not(t, n, o) {
    return this.url.searchParams.append(t, `not.${n}.${o}`), this;
  }
  or(t, { foreignTable: n, referencedTable: o = n } = {}) {
    const r = o ? `${o}.or` : "or";
    return this.url.searchParams.append(r, `(${t})`), this;
  }
  filter(t, n, o) {
    return this.url.searchParams.append(t, `${n}.${o}`), this;
  }
};
ws.default = yN;
var wN =
  (Ct && Ct.__importDefault) ||
  function (e) {
    return e && e.__esModule ? e : { default: e };
  };
Object.defineProperty($l, "__esModule", { value: !0 });
const ma = wN(ws);
let SN = class {
  constructor(t, { headers: n = {}, schema: o, fetch: r }) {
    (this.url = t), (this.headers = n), (this.schema = o), (this.fetch = r);
  }
  select(t, { head: n = !1, count: o } = {}) {
    const r = n ? "HEAD" : "GET";
    let a = !1;
    const s = (t ?? "*")
      .split("")
      .map((i) => (/\s/.test(i) && !a ? "" : (i === '"' && (a = !a), i)))
      .join("");
    return (
      this.url.searchParams.set("select", s),
      o && (this.headers.Prefer = `count=${o}`),
      new ma.default({
        method: r,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        fetch: this.fetch,
        allowEmpty: !1,
      })
    );
  }
  insert(t, { count: n, defaultToNull: o = !0 } = {}) {
    const r = "POST",
      a = [];
    if (
      (this.headers.Prefer && a.push(this.headers.Prefer),
      n && a.push(`count=${n}`),
      o || a.push("missing=default"),
      (this.headers.Prefer = a.join(",")),
      Array.isArray(t))
    ) {
      const s = t.reduce((i, l) => i.concat(Object.keys(l)), []);
      if (s.length > 0) {
        const i = [...new Set(s)].map((l) => `"${l}"`);
        this.url.searchParams.set("columns", i.join(","));
      }
    }
    return new ma.default({
      method: r,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: t,
      fetch: this.fetch,
      allowEmpty: !1,
    });
  }
  upsert(
    t,
    {
      onConflict: n,
      ignoreDuplicates: o = !1,
      count: r,
      defaultToNull: a = !0,
    } = {},
  ) {
    const s = "POST",
      i = [`resolution=${o ? "ignore" : "merge"}-duplicates`];
    if (
      (n !== void 0 && this.url.searchParams.set("on_conflict", n),
      this.headers.Prefer && i.push(this.headers.Prefer),
      r && i.push(`count=${r}`),
      a || i.push("missing=default"),
      (this.headers.Prefer = i.join(",")),
      Array.isArray(t))
    ) {
      const l = t.reduce((c, u) => c.concat(Object.keys(u)), []);
      if (l.length > 0) {
        const c = [...new Set(l)].map((u) => `"${u}"`);
        this.url.searchParams.set("columns", c.join(","));
      }
    }
    return new ma.default({
      method: s,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: t,
      fetch: this.fetch,
      allowEmpty: !1,
    });
  }
  update(t, { count: n } = {}) {
    const o = "PATCH",
      r = [];
    return (
      this.headers.Prefer && r.push(this.headers.Prefer),
      n && r.push(`count=${n}`),
      (this.headers.Prefer = r.join(",")),
      new ma.default({
        method: o,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: t,
        fetch: this.fetch,
        allowEmpty: !1,
      })
    );
  }
  delete({ count: t } = {}) {
    const n = "DELETE",
      o = [];
    return (
      t && o.push(`count=${t}`),
      this.headers.Prefer && o.unshift(this.headers.Prefer),
      (this.headers.Prefer = o.join(",")),
      new ma.default({
        method: n,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        fetch: this.fetch,
        allowEmpty: !1,
      })
    );
  }
};
$l.default = SN;
var Vl = {},
  Wl = {};
Object.defineProperty(Wl, "__esModule", { value: !0 });
Wl.version = void 0;
Wl.version = "0.0.0-automated";
Object.defineProperty(Vl, "__esModule", { value: !0 });
Vl.DEFAULT_HEADERS = void 0;
const bN = Wl;
Vl.DEFAULT_HEADERS = { "X-Client-Info": `postgrest-js/${bN.version}` };
var Iy =
  (Ct && Ct.__importDefault) ||
  function (e) {
    return e && e.__esModule ? e : { default: e };
  };
Object.defineProperty(Jm, "__esModule", { value: !0 });
const CN = Iy($l),
  kN = Iy(ws),
  PN = Vl;
let _N = class Ty {
  constructor(t, { headers: n = {}, schema: o, fetch: r } = {}) {
    (this.url = t),
      (this.headers = Object.assign(Object.assign({}, PN.DEFAULT_HEADERS), n)),
      (this.schemaName = o),
      (this.fetch = r);
  }
  from(t) {
    const n = new URL(`${this.url}/${t}`);
    return new CN.default(n, {
      headers: Object.assign({}, this.headers),
      schema: this.schemaName,
      fetch: this.fetch,
    });
  }
  schema(t) {
    return new Ty(this.url, {
      headers: this.headers,
      schema: t,
      fetch: this.fetch,
    });
  }
  rpc(t, n = {}, { head: o = !1, get: r = !1, count: a } = {}) {
    let s;
    const i = new URL(`${this.url}/rpc/${t}`);
    let l;
    o || r
      ? ((s = o ? "HEAD" : "GET"),
        Object.entries(n)
          .filter(([u, m]) => m !== void 0)
          .map(([u, m]) => [u, Array.isArray(m) ? `{${m.join(",")}}` : `${m}`])
          .forEach(([u, m]) => {
            i.searchParams.append(u, m);
          }))
      : ((s = "POST"), (l = n));
    const c = Object.assign({}, this.headers);
    return (
      a && (c.Prefer = `count=${a}`),
      new kN.default({
        method: s,
        url: i,
        headers: c,
        schema: this.schemaName,
        body: l,
        fetch: this.fetch,
        allowEmpty: !1,
      })
    );
  }
};
Jm.default = _N;
var Xr =
  (Ct && Ct.__importDefault) ||
  function (e) {
    return e && e.__esModule ? e : { default: e };
  };
Object.defineProperty(Ze, "__esModule", { value: !0 });
Ze.PostgrestError =
  Ze.PostgrestBuilder =
  Ze.PostgrestTransformBuilder =
  Ze.PostgrestFilterBuilder =
  Ze.PostgrestQueryBuilder =
  Ze.PostgrestClient =
    void 0;
const jy = Xr(Jm);
Ze.PostgrestClient = jy.default;
const Ry = Xr($l);
Ze.PostgrestQueryBuilder = Ry.default;
const My = Xr(ws);
Ze.PostgrestFilterBuilder = My.default;
const By = Xr(Fl);
Ze.PostgrestTransformBuilder = By.default;
const Ly = Xr(Ul);
Ze.PostgrestBuilder = Ly.default;
const $y = Xr(zl);
Ze.PostgrestError = $y.default;
var AN = (Ze.default = {
  PostgrestClient: jy.default,
  PostgrestQueryBuilder: Ry.default,
  PostgrestFilterBuilder: My.default,
  PostgrestTransformBuilder: By.default,
  PostgrestBuilder: Ly.default,
  PostgrestError: $y.default,
});
const {
    PostgrestClient: DN,
    PostgrestQueryBuilder: t3,
    PostgrestFilterBuilder: n3,
    PostgrestTransformBuilder: o3,
    PostgrestBuilder: r3,
    PostgrestError: a3,
  } = AN,
  EN = "2.11.2",
  NN = { "X-Client-Info": `realtime-js/${EN}` },
  ON = "1.0.0",
  Fy = 1e4,
  IN = 1e3;
var xr;
(function (e) {
  (e[(e.connecting = 0)] = "connecting"),
    (e[(e.open = 1)] = "open"),
    (e[(e.closing = 2)] = "closing"),
    (e[(e.closed = 3)] = "closed");
})(xr || (xr = {}));
var at;
(function (e) {
  (e.closed = "closed"),
    (e.errored = "errored"),
    (e.joined = "joined"),
    (e.joining = "joining"),
    (e.leaving = "leaving");
})(at || (at = {}));
var It;
(function (e) {
  (e.close = "phx_close"),
    (e.error = "phx_error"),
    (e.join = "phx_join"),
    (e.reply = "phx_reply"),
    (e.leave = "phx_leave"),
    (e.access_token = "access_token");
})(It || (It = {}));
var au;
(function (e) {
  e.websocket = "websocket";
})(au || (au = {}));
var vo;
(function (e) {
  (e.Connecting = "connecting"),
    (e.Open = "open"),
    (e.Closing = "closing"),
    (e.Closed = "closed");
})(vo || (vo = {}));
class TN {
  constructor() {
    this.HEADER_LENGTH = 1;
  }
  decode(t, n) {
    return t.constructor === ArrayBuffer
      ? n(this._binaryDecode(t))
      : n(typeof t == "string" ? JSON.parse(t) : {});
  }
  _binaryDecode(t) {
    const n = new DataView(t),
      o = new TextDecoder();
    return this._decodeBroadcast(t, n, o);
  }
  _decodeBroadcast(t, n, o) {
    const r = n.getUint8(1),
      a = n.getUint8(2);
    let s = this.HEADER_LENGTH + 2;
    const i = o.decode(t.slice(s, s + r));
    s = s + r;
    const l = o.decode(t.slice(s, s + a));
    s = s + a;
    const c = JSON.parse(o.decode(t.slice(s, t.byteLength)));
    return { ref: null, topic: i, event: l, payload: c };
  }
}
class Uy {
  constructor(t, n) {
    (this.callback = t),
      (this.timerCalc = n),
      (this.timer = void 0),
      (this.tries = 0),
      (this.callback = t),
      (this.timerCalc = n);
  }
  reset() {
    (this.tries = 0), clearTimeout(this.timer);
  }
  scheduleTimeout() {
    clearTimeout(this.timer),
      (this.timer = setTimeout(
        () => {
          (this.tries = this.tries + 1), this.callback();
        },
        this.timerCalc(this.tries + 1),
      ));
  }
}
var me;
(function (e) {
  (e.abstime = "abstime"),
    (e.bool = "bool"),
    (e.date = "date"),
    (e.daterange = "daterange"),
    (e.float4 = "float4"),
    (e.float8 = "float8"),
    (e.int2 = "int2"),
    (e.int4 = "int4"),
    (e.int4range = "int4range"),
    (e.int8 = "int8"),
    (e.int8range = "int8range"),
    (e.json = "json"),
    (e.jsonb = "jsonb"),
    (e.money = "money"),
    (e.numeric = "numeric"),
    (e.oid = "oid"),
    (e.reltime = "reltime"),
    (e.text = "text"),
    (e.time = "time"),
    (e.timestamp = "timestamp"),
    (e.timestamptz = "timestamptz"),
    (e.timetz = "timetz"),
    (e.tsrange = "tsrange"),
    (e.tstzrange = "tstzrange");
})(me || (me = {}));
const vh = (e, t, n = {}) => {
    var o;
    const r = (o = n.skipTypes) !== null && o !== void 0 ? o : [];
    return Object.keys(t).reduce((a, s) => ((a[s] = jN(s, e, t, r)), a), {});
  },
  jN = (e, t, n, o) => {
    const r = t.find((i) => i.name === e),
      a = r == null ? void 0 : r.type,
      s = n[e];
    return a && !o.includes(a) ? zy(a, s) : su(s);
  },
  zy = (e, t) => {
    if (e.charAt(0) === "_") {
      const n = e.slice(1, e.length);
      return LN(t, n);
    }
    switch (e) {
      case me.bool:
        return RN(t);
      case me.float4:
      case me.float8:
      case me.int2:
      case me.int4:
      case me.int8:
      case me.numeric:
      case me.oid:
        return MN(t);
      case me.json:
      case me.jsonb:
        return BN(t);
      case me.timestamp:
        return $N(t);
      case me.abstime:
      case me.date:
      case me.daterange:
      case me.int4range:
      case me.int8range:
      case me.money:
      case me.reltime:
      case me.text:
      case me.time:
      case me.timestamptz:
      case me.timetz:
      case me.tsrange:
      case me.tstzrange:
        return su(t);
      default:
        return su(t);
    }
  },
  su = (e) => e,
  RN = (e) => {
    switch (e) {
      case "t":
        return !0;
      case "f":
        return !1;
      default:
        return e;
    }
  },
  MN = (e) => {
    if (typeof e == "string") {
      const t = parseFloat(e);
      if (!Number.isNaN(t)) return t;
    }
    return e;
  },
  BN = (e) => {
    if (typeof e == "string")
      try {
        return JSON.parse(e);
      } catch (t) {
        return console.log(`JSON parse error: ${t}`), e;
      }
    return e;
  },
  LN = (e, t) => {
    if (typeof e != "string") return e;
    const n = e.length - 1,
      o = e[n];
    if (e[0] === "{" && o === "}") {
      let a;
      const s = e.slice(1, n);
      try {
        a = JSON.parse("[" + s + "]");
      } catch {
        a = s ? s.split(",") : [];
      }
      return a.map((i) => zy(t, i));
    }
    return e;
  },
  $N = (e) => (typeof e == "string" ? e.replace(" ", "T") : e),
  Vy = (e) => {
    let t = e;
    return (
      (t = t.replace(/^ws/i, "http")),
      (t = t.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, "")),
      t.replace(/\/+$/, "")
    );
  };
class Bc {
  constructor(t, n, o = {}, r = Fy) {
    (this.channel = t),
      (this.event = n),
      (this.payload = o),
      (this.timeout = r),
      (this.sent = !1),
      (this.timeoutTimer = void 0),
      (this.ref = ""),
      (this.receivedResp = null),
      (this.recHooks = []),
      (this.refEvent = null);
  }
  resend(t) {
    (this.timeout = t),
      this._cancelRefEvent(),
      (this.ref = ""),
      (this.refEvent = null),
      (this.receivedResp = null),
      (this.sent = !1),
      this.send();
  }
  send() {
    this._hasReceived("timeout") ||
      (this.startTimeout(),
      (this.sent = !0),
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload,
        ref: this.ref,
        join_ref: this.channel._joinRef(),
      }));
  }
  updatePayload(t) {
    this.payload = Object.assign(Object.assign({}, this.payload), t);
  }
  receive(t, n) {
    var o;
    return (
      this._hasReceived(t) &&
        n(
          (o = this.receivedResp) === null || o === void 0
            ? void 0
            : o.response,
        ),
      this.recHooks.push({ status: t, callback: n }),
      this
    );
  }
  startTimeout() {
    if (this.timeoutTimer) return;
    (this.ref = this.channel.socket._makeRef()),
      (this.refEvent = this.channel._replyEventName(this.ref));
    const t = (n) => {
      this._cancelRefEvent(),
        this._cancelTimeout(),
        (this.receivedResp = n),
        this._matchReceive(n);
    };
    this.channel._on(this.refEvent, {}, t),
      (this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout));
  }
  trigger(t, n) {
    this.refEvent &&
      this.channel._trigger(this.refEvent, { status: t, response: n });
  }
  destroy() {
    this._cancelRefEvent(), this._cancelTimeout();
  }
  _cancelRefEvent() {
    this.refEvent && this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer), (this.timeoutTimer = void 0);
  }
  _matchReceive({ status: t, response: n }) {
    this.recHooks.filter((o) => o.status === t).forEach((o) => o.callback(n));
  }
  _hasReceived(t) {
    return this.receivedResp && this.receivedResp.status === t;
  }
}
var gh;
(function (e) {
  (e.SYNC = "sync"), (e.JOIN = "join"), (e.LEAVE = "leave");
})(gh || (gh = {}));
class Oa {
  constructor(t, n) {
    (this.channel = t),
      (this.state = {}),
      (this.pendingDiffs = []),
      (this.joinRef = null),
      (this.caller = { onJoin: () => {}, onLeave: () => {}, onSync: () => {} });
    const o = (n == null ? void 0 : n.events) || {
      state: "presence_state",
      diff: "presence_diff",
    };
    this.channel._on(o.state, {}, (r) => {
      const { onJoin: a, onLeave: s, onSync: i } = this.caller;
      (this.joinRef = this.channel._joinRef()),
        (this.state = Oa.syncState(this.state, r, a, s)),
        this.pendingDiffs.forEach((l) => {
          this.state = Oa.syncDiff(this.state, l, a, s);
        }),
        (this.pendingDiffs = []),
        i();
    }),
      this.channel._on(o.diff, {}, (r) => {
        const { onJoin: a, onLeave: s, onSync: i } = this.caller;
        this.inPendingSyncState()
          ? this.pendingDiffs.push(r)
          : ((this.state = Oa.syncDiff(this.state, r, a, s)), i());
      }),
      this.onJoin((r, a, s) => {
        this.channel._trigger("presence", {
          event: "join",
          key: r,
          currentPresences: a,
          newPresences: s,
        });
      }),
      this.onLeave((r, a, s) => {
        this.channel._trigger("presence", {
          event: "leave",
          key: r,
          currentPresences: a,
          leftPresences: s,
        });
      }),
      this.onSync(() => {
        this.channel._trigger("presence", { event: "sync" });
      });
  }
  static syncState(t, n, o, r) {
    const a = this.cloneDeep(t),
      s = this.transformState(n),
      i = {},
      l = {};
    return (
      this.map(a, (c, u) => {
        s[c] || (l[c] = u);
      }),
      this.map(s, (c, u) => {
        const m = a[c];
        if (m) {
          const p = u.map((w) => w.presence_ref),
            h = m.map((w) => w.presence_ref),
            g = u.filter((w) => h.indexOf(w.presence_ref) < 0),
            v = m.filter((w) => p.indexOf(w.presence_ref) < 0);
          g.length > 0 && (i[c] = g), v.length > 0 && (l[c] = v);
        } else i[c] = u;
      }),
      this.syncDiff(a, { joins: i, leaves: l }, o, r)
    );
  }
  static syncDiff(t, n, o, r) {
    const { joins: a, leaves: s } = {
      joins: this.transformState(n.joins),
      leaves: this.transformState(n.leaves),
    };
    return (
      o || (o = () => {}),
      r || (r = () => {}),
      this.map(a, (i, l) => {
        var c;
        const u = (c = t[i]) !== null && c !== void 0 ? c : [];
        if (((t[i] = this.cloneDeep(l)), u.length > 0)) {
          const m = t[i].map((h) => h.presence_ref),
            p = u.filter((h) => m.indexOf(h.presence_ref) < 0);
          t[i].unshift(...p);
        }
        o(i, u, l);
      }),
      this.map(s, (i, l) => {
        let c = t[i];
        if (!c) return;
        const u = l.map((m) => m.presence_ref);
        (c = c.filter((m) => u.indexOf(m.presence_ref) < 0)),
          (t[i] = c),
          r(i, c, l),
          c.length === 0 && delete t[i];
      }),
      t
    );
  }
  static map(t, n) {
    return Object.getOwnPropertyNames(t).map((o) => n(o, t[o]));
  }
  static transformState(t) {
    return (
      (t = this.cloneDeep(t)),
      Object.getOwnPropertyNames(t).reduce((n, o) => {
        const r = t[o];
        return (
          "metas" in r
            ? (n[o] = r.metas.map(
                (a) => (
                  (a.presence_ref = a.phx_ref),
                  delete a.phx_ref,
                  delete a.phx_ref_prev,
                  a
                ),
              ))
            : (n[o] = r),
          n
        );
      }, {})
    );
  }
  static cloneDeep(t) {
    return JSON.parse(JSON.stringify(t));
  }
  onJoin(t) {
    this.caller.onJoin = t;
  }
  onLeave(t) {
    this.caller.onLeave = t;
  }
  onSync(t) {
    this.caller.onSync = t;
  }
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
}
var xh;
(function (e) {
  (e.ALL = "*"),
    (e.INSERT = "INSERT"),
    (e.UPDATE = "UPDATE"),
    (e.DELETE = "DELETE");
})(xh || (xh = {}));
var yh;
(function (e) {
  (e.BROADCAST = "broadcast"),
    (e.PRESENCE = "presence"),
    (e.POSTGRES_CHANGES = "postgres_changes"),
    (e.SYSTEM = "system");
})(yh || (yh = {}));
var sn;
(function (e) {
  (e.SUBSCRIBED = "SUBSCRIBED"),
    (e.TIMED_OUT = "TIMED_OUT"),
    (e.CLOSED = "CLOSED"),
    (e.CHANNEL_ERROR = "CHANNEL_ERROR");
})(sn || (sn = {}));
class Ym {
  constructor(t, n = { config: {} }, o) {
    (this.topic = t),
      (this.params = n),
      (this.socket = o),
      (this.bindings = {}),
      (this.state = at.closed),
      (this.joinedOnce = !1),
      (this.pushBuffer = []),
      (this.subTopic = t.replace(/^realtime:/i, "")),
      (this.params.config = Object.assign(
        {
          broadcast: { ack: !1, self: !1 },
          presence: { key: "" },
          private: !1,
        },
        n.config,
      )),
      (this.timeout = this.socket.timeout),
      (this.joinPush = new Bc(this, It.join, this.params, this.timeout)),
      (this.rejoinTimer = new Uy(
        () => this._rejoinUntilConnected(),
        this.socket.reconnectAfterMs,
      )),
      this.joinPush.receive("ok", () => {
        (this.state = at.joined),
          this.rejoinTimer.reset(),
          this.pushBuffer.forEach((r) => r.send()),
          (this.pushBuffer = []);
      }),
      this._onClose(() => {
        this.rejoinTimer.reset(),
          this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`),
          (this.state = at.closed),
          this.socket._remove(this);
      }),
      this._onError((r) => {
        this._isLeaving() ||
          this._isClosed() ||
          (this.socket.log("channel", `error ${this.topic}`, r),
          (this.state = at.errored),
          this.rejoinTimer.scheduleTimeout());
      }),
      this.joinPush.receive("timeout", () => {
        this._isJoining() &&
          (this.socket.log(
            "channel",
            `timeout ${this.topic}`,
            this.joinPush.timeout,
          ),
          (this.state = at.errored),
          this.rejoinTimer.scheduleTimeout());
      }),
      this._on(It.reply, {}, (r, a) => {
        this._trigger(this._replyEventName(a), r);
      }),
      (this.presence = new Oa(this)),
      (this.broadcastEndpointURL = Vy(this.socket.endPoint) + "/api/broadcast"),
      (this.private = this.params.config.private || !1);
  }
  subscribe(t, n = this.timeout) {
    var o, r;
    if ((this.socket.isConnected() || this.socket.connect(), this.joinedOnce))
      throw "tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance";
    {
      const {
        config: { broadcast: a, presence: s, private: i },
      } = this.params;
      this._onError((u) => (t == null ? void 0 : t(sn.CHANNEL_ERROR, u))),
        this._onClose(() => (t == null ? void 0 : t(sn.CLOSED)));
      const l = {},
        c = {
          broadcast: a,
          presence: s,
          postgres_changes:
            (r =
              (o = this.bindings.postgres_changes) === null || o === void 0
                ? void 0
                : o.map((u) => u.filter)) !== null && r !== void 0
              ? r
              : [],
          private: i,
        };
      this.socket.accessTokenValue &&
        (l.access_token = this.socket.accessTokenValue),
        this.updateJoinPayload(Object.assign({ config: c }, l)),
        (this.joinedOnce = !0),
        this._rejoin(n),
        this.joinPush
          .receive("ok", async ({ postgres_changes: u }) => {
            var m;
            if ((this.socket.setAuth(), u === void 0)) {
              t == null || t(sn.SUBSCRIBED);
              return;
            } else {
              const p = this.bindings.postgres_changes,
                h =
                  (m = p == null ? void 0 : p.length) !== null && m !== void 0
                    ? m
                    : 0,
                g = [];
              for (let v = 0; v < h; v++) {
                const w = p[v],
                  {
                    filter: { event: y, schema: x, table: S, filter: b },
                  } = w,
                  C = u && u[v];
                if (
                  C &&
                  C.event === y &&
                  C.schema === x &&
                  C.table === S &&
                  C.filter === b
                )
                  g.push(Object.assign(Object.assign({}, w), { id: C.id }));
                else {
                  this.unsubscribe(),
                    t == null ||
                      t(
                        sn.CHANNEL_ERROR,
                        new Error(
                          "mismatch between server and client bindings for postgres changes",
                        ),
                      );
                  return;
                }
              }
              (this.bindings.postgres_changes = g), t && t(sn.SUBSCRIBED);
              return;
            }
          })
          .receive("error", (u) => {
            t == null ||
              t(
                sn.CHANNEL_ERROR,
                new Error(
                  JSON.stringify(Object.values(u).join(", ") || "error"),
                ),
              );
          })
          .receive("timeout", () => {
            t == null || t(sn.TIMED_OUT);
          });
    }
    return this;
  }
  presenceState() {
    return this.presence.state;
  }
  async track(t, n = {}) {
    return await this.send(
      { type: "presence", event: "track", payload: t },
      n.timeout || this.timeout,
    );
  }
  async untrack(t = {}) {
    return await this.send({ type: "presence", event: "untrack" }, t);
  }
  on(t, n, o) {
    return this._on(t, n, o);
  }
  async send(t, n = {}) {
    var o, r;
    if (!this._canPush() && t.type === "broadcast") {
      const { event: a, payload: s } = t,
        l = {
          method: "POST",
          headers: {
            Authorization: this.socket.accessTokenValue
              ? `Bearer ${this.socket.accessTokenValue}`
              : "",
            apikey: this.socket.apiKey ? this.socket.apiKey : "",
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            messages: [
              {
                topic: this.subTopic,
                event: a,
                payload: s,
                private: this.private,
              },
            ],
          }),
        };
      try {
        const c = await this._fetchWithTimeout(
          this.broadcastEndpointURL,
          l,
          (o = n.timeout) !== null && o !== void 0 ? o : this.timeout,
        );
        return (
          await ((r = c.body) === null || r === void 0 ? void 0 : r.cancel()),
          c.ok ? "ok" : "error"
        );
      } catch (c) {
        return c.name === "AbortError" ? "timed out" : "error";
      }
    } else
      return new Promise((a) => {
        var s, i, l;
        const c = this._push(t.type, t, n.timeout || this.timeout);
        t.type === "broadcast" &&
          !(
            !(
              (l =
                (i =
                  (s = this.params) === null || s === void 0
                    ? void 0
                    : s.config) === null || i === void 0
                  ? void 0
                  : i.broadcast) === null || l === void 0
            ) && l.ack
          ) &&
          a("ok"),
          c.receive("ok", () => a("ok")),
          c.receive("error", () => a("error")),
          c.receive("timeout", () => a("timed out"));
      });
  }
  updateJoinPayload(t) {
    this.joinPush.updatePayload(t);
  }
  unsubscribe(t = this.timeout) {
    this.state = at.leaving;
    const n = () => {
      this.socket.log("channel", `leave ${this.topic}`),
        this._trigger(It.close, "leave", this._joinRef());
    };
    return (
      this.rejoinTimer.reset(),
      this.joinPush.destroy(),
      new Promise((o) => {
        const r = new Bc(this, It.leave, {}, t);
        r
          .receive("ok", () => {
            n(), o("ok");
          })
          .receive("timeout", () => {
            n(), o("timed out");
          })
          .receive("error", () => {
            o("error");
          }),
          r.send(),
          this._canPush() || r.trigger("ok", {});
      })
    );
  }
  async _fetchWithTimeout(t, n, o) {
    const r = new AbortController(),
      a = setTimeout(() => r.abort(), o),
      s = await this.socket.fetch(
        t,
        Object.assign(Object.assign({}, n), { signal: r.signal }),
      );
    return clearTimeout(a), s;
  }
  _push(t, n, o = this.timeout) {
    if (!this.joinedOnce)
      throw `tried to push '${t}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    let r = new Bc(this, t, n, o);
    return (
      this._canPush() ? r.send() : (r.startTimeout(), this.pushBuffer.push(r)),
      r
    );
  }
  _onMessage(t, n, o) {
    return n;
  }
  _isMember(t) {
    return this.topic === t;
  }
  _joinRef() {
    return this.joinPush.ref;
  }
  _trigger(t, n, o) {
    var r, a;
    const s = t.toLocaleLowerCase(),
      { close: i, error: l, leave: c, join: u } = It;
    if (o && [i, l, c, u].indexOf(s) >= 0 && o !== this._joinRef()) return;
    let p = this._onMessage(s, n, o);
    if (n && !p)
      throw "channel onMessage callbacks must return the payload, modified or unmodified";
    ["insert", "update", "delete"].includes(s)
      ? (r = this.bindings.postgres_changes) === null ||
        r === void 0 ||
        r
          .filter((h) => {
            var g, v, w;
            return (
              ((g = h.filter) === null || g === void 0 ? void 0 : g.event) ===
                "*" ||
              ((w =
                (v = h.filter) === null || v === void 0 ? void 0 : v.event) ===
                null || w === void 0
                ? void 0
                : w.toLocaleLowerCase()) === s
            );
          })
          .map((h) => h.callback(p, o))
      : (a = this.bindings[s]) === null ||
        a === void 0 ||
        a
          .filter((h) => {
            var g, v, w, y, x, S;
            if (["broadcast", "presence", "postgres_changes"].includes(s))
              if ("id" in h) {
                const b = h.id,
                  C =
                    (g = h.filter) === null || g === void 0 ? void 0 : g.event;
                return (
                  b &&
                  ((v = n.ids) === null || v === void 0
                    ? void 0
                    : v.includes(b)) &&
                  (C === "*" ||
                    (C == null ? void 0 : C.toLocaleLowerCase()) ===
                      ((w = n.data) === null || w === void 0
                        ? void 0
                        : w.type.toLocaleLowerCase()))
                );
              } else {
                const b =
                  (x =
                    (y = h == null ? void 0 : h.filter) === null || y === void 0
                      ? void 0
                      : y.event) === null || x === void 0
                    ? void 0
                    : x.toLocaleLowerCase();
                return (
                  b === "*" ||
                  b ===
                    ((S = n == null ? void 0 : n.event) === null || S === void 0
                      ? void 0
                      : S.toLocaleLowerCase())
                );
              }
            else return h.type.toLocaleLowerCase() === s;
          })
          .map((h) => {
            if (typeof p == "object" && "ids" in p) {
              const g = p.data,
                {
                  schema: v,
                  table: w,
                  commit_timestamp: y,
                  type: x,
                  errors: S,
                } = g;
              p = Object.assign(
                Object.assign(
                  {},
                  {
                    schema: v,
                    table: w,
                    commit_timestamp: y,
                    eventType: x,
                    new: {},
                    old: {},
                    errors: S,
                  },
                ),
                this._getPayloadRecords(g),
              );
            }
            h.callback(p, o);
          });
  }
  _isClosed() {
    return this.state === at.closed;
  }
  _isJoined() {
    return this.state === at.joined;
  }
  _isJoining() {
    return this.state === at.joining;
  }
  _isLeaving() {
    return this.state === at.leaving;
  }
  _replyEventName(t) {
    return `chan_reply_${t}`;
  }
  _on(t, n, o) {
    const r = t.toLocaleLowerCase(),
      a = { type: r, filter: n, callback: o };
    return (
      this.bindings[r] ? this.bindings[r].push(a) : (this.bindings[r] = [a]),
      this
    );
  }
  _off(t, n) {
    const o = t.toLocaleLowerCase();
    return (
      (this.bindings[o] = this.bindings[o].filter((r) => {
        var a;
        return !(
          ((a = r.type) === null || a === void 0
            ? void 0
            : a.toLocaleLowerCase()) === o && Ym.isEqual(r.filter, n)
        );
      })),
      this
    );
  }
  static isEqual(t, n) {
    if (Object.keys(t).length !== Object.keys(n).length) return !1;
    for (const o in t) if (t[o] !== n[o]) return !1;
    return !0;
  }
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout(),
      this.socket.isConnected() && this._rejoin();
  }
  _onClose(t) {
    this._on(It.close, {}, t);
  }
  _onError(t) {
    this._on(It.error, {}, (n) => t(n));
  }
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  _rejoin(t = this.timeout) {
    this._isLeaving() ||
      (this.socket._leaveOpenTopic(this.topic),
      (this.state = at.joining),
      this.joinPush.resend(t));
  }
  _getPayloadRecords(t) {
    const n = { new: {}, old: {} };
    return (
      (t.type === "INSERT" || t.type === "UPDATE") &&
        (n.new = vh(t.columns, t.record)),
      (t.type === "UPDATE" || t.type === "DELETE") &&
        (n.old = vh(t.columns, t.old_record)),
      n
    );
  }
}
const FN = () => {},
  UN = typeof WebSocket < "u",
  zN = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
class VN {
  constructor(t, n) {
    var o;
    (this.accessTokenValue = null),
      (this.apiKey = null),
      (this.channels = []),
      (this.endPoint = ""),
      (this.httpEndpoint = ""),
      (this.headers = NN),
      (this.params = {}),
      (this.timeout = Fy),
      (this.heartbeatIntervalMs = 3e4),
      (this.heartbeatTimer = void 0),
      (this.pendingHeartbeatRef = null),
      (this.ref = 0),
      (this.logger = FN),
      (this.conn = null),
      (this.sendBuffer = []),
      (this.serializer = new TN()),
      (this.stateChangeCallbacks = {
        open: [],
        close: [],
        error: [],
        message: [],
      }),
      (this.accessToken = null),
      (this._resolveFetch = (a) => {
        let s;
        return (
          a
            ? (s = a)
            : typeof fetch > "u"
              ? (s = (...i) =>
                  Br(
                    async () => {
                      const { default: l } = await Promise.resolve().then(
                        () => Yr,
                      );
                      return { default: l };
                    },
                    void 0,
                  ).then(({ default: l }) => l(...i)))
              : (s = fetch),
          (...i) => s(...i)
        );
      }),
      (this.endPoint = `${t}/${au.websocket}`),
      (this.httpEndpoint = Vy(t)),
      n != null && n.transport
        ? (this.transport = n.transport)
        : (this.transport = null),
      n != null && n.params && (this.params = n.params),
      n != null &&
        n.headers &&
        (this.headers = Object.assign(
          Object.assign({}, this.headers),
          n.headers,
        )),
      n != null && n.timeout && (this.timeout = n.timeout),
      n != null && n.logger && (this.logger = n.logger),
      n != null &&
        n.heartbeatIntervalMs &&
        (this.heartbeatIntervalMs = n.heartbeatIntervalMs);
    const r =
      (o = n == null ? void 0 : n.params) === null || o === void 0
        ? void 0
        : o.apikey;
    if (
      (r && ((this.accessTokenValue = r), (this.apiKey = r)),
      (this.reconnectAfterMs =
        n != null && n.reconnectAfterMs
          ? n.reconnectAfterMs
          : (a) => [1e3, 2e3, 5e3, 1e4][a - 1] || 1e4),
      (this.encode =
        n != null && n.encode ? n.encode : (a, s) => s(JSON.stringify(a))),
      (this.decode =
        n != null && n.decode
          ? n.decode
          : this.serializer.decode.bind(this.serializer)),
      (this.reconnectTimer = new Uy(async () => {
        this.disconnect(), this.connect();
      }, this.reconnectAfterMs)),
      (this.fetch = this._resolveFetch(n == null ? void 0 : n.fetch)),
      n != null && n.worker)
    ) {
      if (typeof window < "u" && !window.Worker)
        throw new Error("Web Worker is not supported");
      (this.worker = (n == null ? void 0 : n.worker) || !1),
        (this.workerUrl = n == null ? void 0 : n.workerUrl);
    }
    this.accessToken = (n == null ? void 0 : n.accessToken) || null;
  }
  connect() {
    if (!this.conn) {
      if (this.transport) {
        this.conn = new this.transport(this.endpointURL(), void 0, {
          headers: this.headers,
        });
        return;
      }
      if (UN) {
        (this.conn = new WebSocket(this.endpointURL())), this.setupConnection();
        return;
      }
      (this.conn = new WN(this.endpointURL(), void 0, {
        close: () => {
          this.conn = null;
        },
      })),
        Br(async () => {
          const { default: t } = await import("./browser-Dz2MTh9n.js").then(
            (n) => n.b,
          );
          return { default: t };
        }, []).then(({ default: t }) => {
          (this.conn = new t(this.endpointURL(), void 0, {
            headers: this.headers,
          })),
            this.setupConnection();
        });
    }
  }
  endpointURL() {
    return this._appendParams(
      this.endPoint,
      Object.assign({}, this.params, { vsn: ON }),
    );
  }
  disconnect(t, n) {
    this.conn &&
      ((this.conn.onclose = function () {}),
      t ? this.conn.close(t, n ?? "") : this.conn.close(),
      (this.conn = null),
      this.heartbeatTimer && clearInterval(this.heartbeatTimer),
      this.reconnectTimer.reset());
  }
  getChannels() {
    return this.channels;
  }
  async removeChannel(t) {
    const n = await t.unsubscribe();
    return this.channels.length === 0 && this.disconnect(), n;
  }
  async removeAllChannels() {
    const t = await Promise.all(this.channels.map((n) => n.unsubscribe()));
    return this.disconnect(), t;
  }
  log(t, n, o) {
    this.logger(t, n, o);
  }
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case xr.connecting:
        return vo.Connecting;
      case xr.open:
        return vo.Open;
      case xr.closing:
        return vo.Closing;
      default:
        return vo.Closed;
    }
  }
  isConnected() {
    return this.connectionState() === vo.Open;
  }
  channel(t, n = { config: {} }) {
    const o = new Ym(`realtime:${t}`, n, this);
    return this.channels.push(o), o;
  }
  push(t) {
    const { topic: n, event: o, payload: r, ref: a } = t,
      s = () => {
        this.encode(t, (i) => {
          var l;
          (l = this.conn) === null || l === void 0 || l.send(i);
        });
      };
    this.log("push", `${n} ${o} (${a})`, r),
      this.isConnected() ? s() : this.sendBuffer.push(s);
  }
  async setAuth(t = null) {
    let n =
      t ||
      (this.accessToken && (await this.accessToken())) ||
      this.accessTokenValue;
    if (n) {
      let o = null;
      try {
        o = JSON.parse(atob(n.split(".")[1]));
      } catch {}
      if (o && o.exp && !(Math.floor(Date.now() / 1e3) - o.exp < 0))
        return (
          this.log(
            "auth",
            `InvalidJWTToken: Invalid value for JWT claim "exp" with value ${o.exp}`,
          ),
          Promise.reject(
            `InvalidJWTToken: Invalid value for JWT claim "exp" with value ${o.exp}`,
          )
        );
      (this.accessTokenValue = n),
        this.channels.forEach((r) => {
          n && r.updateJoinPayload({ access_token: n }),
            r.joinedOnce &&
              r._isJoined() &&
              r._push(It.access_token, { access_token: n });
        });
    }
  }
  async sendHeartbeat() {
    var t;
    if (this.isConnected()) {
      if (this.pendingHeartbeatRef) {
        (this.pendingHeartbeatRef = null),
          this.log(
            "transport",
            "heartbeat timeout. Attempting to re-establish connection",
          ),
          (t = this.conn) === null ||
            t === void 0 ||
            t.close(IN, "hearbeat timeout");
        return;
      }
      (this.pendingHeartbeatRef = this._makeRef()),
        this.push({
          topic: "phoenix",
          event: "heartbeat",
          payload: {},
          ref: this.pendingHeartbeatRef,
        }),
        this.setAuth();
    }
  }
  flushSendBuffer() {
    this.isConnected() &&
      this.sendBuffer.length > 0 &&
      (this.sendBuffer.forEach((t) => t()), (this.sendBuffer = []));
  }
  _makeRef() {
    let t = this.ref + 1;
    return (
      t === this.ref ? (this.ref = 0) : (this.ref = t), this.ref.toString()
    );
  }
  _leaveOpenTopic(t) {
    let n = this.channels.find(
      (o) => o.topic === t && (o._isJoined() || o._isJoining()),
    );
    n &&
      (this.log("transport", `leaving duplicate topic "${t}"`),
      n.unsubscribe());
  }
  _remove(t) {
    this.channels = this.channels.filter((n) => n._joinRef() !== t._joinRef());
  }
  setupConnection() {
    this.conn &&
      ((this.conn.binaryType = "arraybuffer"),
      (this.conn.onopen = () => this._onConnOpen()),
      (this.conn.onerror = (t) => this._onConnError(t)),
      (this.conn.onmessage = (t) => this._onConnMessage(t)),
      (this.conn.onclose = (t) => this._onConnClose(t)));
  }
  _onConnMessage(t) {
    this.decode(t.data, (n) => {
      let { topic: o, event: r, payload: a, ref: s } = n;
      s && s === this.pendingHeartbeatRef && (this.pendingHeartbeatRef = null),
        this.log(
          "receive",
          `${a.status || ""} ${o} ${r} ${(s && "(" + s + ")") || ""}`,
          a,
        ),
        this.channels
          .filter((i) => i._isMember(o))
          .forEach((i) => i._trigger(r, a, s)),
        this.stateChangeCallbacks.message.forEach((i) => i(n));
    });
  }
  async _onConnOpen() {
    if (
      (this.log("transport", `connected to ${this.endpointURL()}`),
      this.flushSendBuffer(),
      this.reconnectTimer.reset(),
      !this.worker)
    )
      this.heartbeatTimer && clearInterval(this.heartbeatTimer),
        (this.heartbeatTimer = setInterval(
          () => this.sendHeartbeat(),
          this.heartbeatIntervalMs,
        ));
    else {
      this.workerUrl
        ? this.log("worker", `starting worker for from ${this.workerUrl}`)
        : this.log("worker", "starting default worker");
      const t = this._workerObjectUrl(this.workerUrl);
      (this.workerRef = new Worker(t)),
        (this.workerRef.onerror = (n) => {
          this.log("worker", "worker error", n.message),
            this.workerRef.terminate();
        }),
        (this.workerRef.onmessage = (n) => {
          n.data.event === "keepAlive" && this.sendHeartbeat();
        }),
        this.workerRef.postMessage({
          event: "start",
          interval: this.heartbeatIntervalMs,
        });
    }
    this.stateChangeCallbacks.open.forEach((t) => t());
  }
  _onConnClose(t) {
    this.log("transport", "close", t),
      this._triggerChanError(),
      this.heartbeatTimer && clearInterval(this.heartbeatTimer),
      this.reconnectTimer.scheduleTimeout(),
      this.stateChangeCallbacks.close.forEach((n) => n(t));
  }
  _onConnError(t) {
    this.log("transport", t.message),
      this._triggerChanError(),
      this.stateChangeCallbacks.error.forEach((n) => n(t));
  }
  _triggerChanError() {
    this.channels.forEach((t) => t._trigger(It.error));
  }
  _appendParams(t, n) {
    if (Object.keys(n).length === 0) return t;
    const o = t.match(/\?/) ? "&" : "?",
      r = new URLSearchParams(n);
    return `${t}${o}${r}`;
  }
  _workerObjectUrl(t) {
    let n;
    if (t) n = t;
    else {
      const o = new Blob([zN], { type: "application/javascript" });
      n = URL.createObjectURL(o);
    }
    return n;
  }
}
class WN {
  constructor(t, n, o) {
    (this.binaryType = "arraybuffer"),
      (this.onclose = () => {}),
      (this.onerror = () => {}),
      (this.onmessage = () => {}),
      (this.onopen = () => {}),
      (this.readyState = xr.connecting),
      (this.send = () => {}),
      (this.url = null),
      (this.url = t),
      (this.close = o.close);
  }
}
class Xm extends Error {
  constructor(t) {
    super(t), (this.__isStorageError = !0), (this.name = "StorageError");
  }
}
function Ee(e) {
  return typeof e == "object" && e !== null && "__isStorageError" in e;
}
class GN extends Xm {
  constructor(t, n) {
    super(t), (this.name = "StorageApiError"), (this.status = n);
  }
  toJSON() {
    return { name: this.name, message: this.message, status: this.status };
  }
}
class iu extends Xm {
  constructor(t, n) {
    super(t), (this.name = "StorageUnknownError"), (this.originalError = n);
  }
}
var HN = function (e, t, n, o) {
  function r(a) {
    return a instanceof n
      ? a
      : new n(function (s) {
          s(a);
        });
  }
  return new (n || (n = Promise))(function (a, s) {
    function i(u) {
      try {
        c(o.next(u));
      } catch (m) {
        s(m);
      }
    }
    function l(u) {
      try {
        c(o.throw(u));
      } catch (m) {
        s(m);
      }
    }
    function c(u) {
      u.done ? a(u.value) : r(u.value).then(i, l);
    }
    c((o = o.apply(e, t || [])).next());
  });
};
const Wy = (e) => {
    let t;
    return (
      e
        ? (t = e)
        : typeof fetch > "u"
          ? (t = (...n) =>
              Br(
                async () => {
                  const { default: o } = await Promise.resolve().then(() => Yr);
                  return { default: o };
                },
                void 0,
              ).then(({ default: o }) => o(...n)))
          : (t = fetch),
      (...n) => t(...n)
    );
  },
  KN = () =>
    HN(void 0, void 0, void 0, function* () {
      return typeof Response > "u"
        ? (yield Br(() => Promise.resolve().then(() => Yr), void 0)).Response
        : Response;
    }),
  lu = (e) => {
    if (Array.isArray(e)) return e.map((n) => lu(n));
    if (typeof e == "function" || e !== Object(e)) return e;
    const t = {};
    return (
      Object.entries(e).forEach(([n, o]) => {
        const r = n.replace(/([-_][a-z])/gi, (a) =>
          a.toUpperCase().replace(/[-_]/g, ""),
        );
        t[r] = lu(o);
      }),
      t
    );
  };
var Lo = function (e, t, n, o) {
  function r(a) {
    return a instanceof n
      ? a
      : new n(function (s) {
          s(a);
        });
  }
  return new (n || (n = Promise))(function (a, s) {
    function i(u) {
      try {
        c(o.next(u));
      } catch (m) {
        s(m);
      }
    }
    function l(u) {
      try {
        c(o.throw(u));
      } catch (m) {
        s(m);
      }
    }
    function c(u) {
      u.done ? a(u.value) : r(u.value).then(i, l);
    }
    c((o = o.apply(e, t || [])).next());
  });
};
const Lc = (e) =>
    e.msg || e.message || e.error_description || e.error || JSON.stringify(e),
  qN = (e, t, n) =>
    Lo(void 0, void 0, void 0, function* () {
      const o = yield KN();
      e instanceof o && !(n != null && n.noResolveJson)
        ? e
            .json()
            .then((r) => {
              t(new GN(Lc(r), e.status || 500));
            })
            .catch((r) => {
              t(new iu(Lc(r), r));
            })
        : t(new iu(Lc(e), e));
    }),
  QN = (e, t, n, o) => {
    const r = { method: e, headers: (t == null ? void 0 : t.headers) || {} };
    return e === "GET"
      ? r
      : ((r.headers = Object.assign(
          { "Content-Type": "application/json" },
          t == null ? void 0 : t.headers,
        )),
        o && (r.body = JSON.stringify(o)),
        Object.assign(Object.assign({}, r), n));
  };
function Ss(e, t, n, o, r, a) {
  return Lo(this, void 0, void 0, function* () {
    return new Promise((s, i) => {
      e(n, QN(t, o, r, a))
        .then((l) => {
          if (!l.ok) throw l;
          return o != null && o.noResolveJson ? l : l.json();
        })
        .then((l) => s(l))
        .catch((l) => qN(l, i, o));
    });
  });
}
function Xi(e, t, n, o) {
  return Lo(this, void 0, void 0, function* () {
    return Ss(e, "GET", t, n, o);
  });
}
function En(e, t, n, o, r) {
  return Lo(this, void 0, void 0, function* () {
    return Ss(e, "POST", t, o, r, n);
  });
}
function JN(e, t, n, o, r) {
  return Lo(this, void 0, void 0, function* () {
    return Ss(e, "PUT", t, o, r, n);
  });
}
function YN(e, t, n, o) {
  return Lo(this, void 0, void 0, function* () {
    return Ss(
      e,
      "HEAD",
      t,
      Object.assign(Object.assign({}, n), { noResolveJson: !0 }),
      o,
    );
  });
}
function Gy(e, t, n, o, r) {
  return Lo(this, void 0, void 0, function* () {
    return Ss(e, "DELETE", t, o, r, n);
  });
}
var Ye = function (e, t, n, o) {
  function r(a) {
    return a instanceof n
      ? a
      : new n(function (s) {
          s(a);
        });
  }
  return new (n || (n = Promise))(function (a, s) {
    function i(u) {
      try {
        c(o.next(u));
      } catch (m) {
        s(m);
      }
    }
    function l(u) {
      try {
        c(o.throw(u));
      } catch (m) {
        s(m);
      }
    }
    function c(u) {
      u.done ? a(u.value) : r(u.value).then(i, l);
    }
    c((o = o.apply(e, t || [])).next());
  });
};
const XN = { limit: 100, offset: 0, sortBy: { column: "name", order: "asc" } },
  wh = {
    cacheControl: "3600",
    contentType: "text/plain;charset=UTF-8",
    upsert: !1,
  };
class ZN {
  constructor(t, n = {}, o, r) {
    (this.url = t),
      (this.headers = n),
      (this.bucketId = o),
      (this.fetch = Wy(r));
  }
  uploadOrUpdate(t, n, o, r) {
    return Ye(this, void 0, void 0, function* () {
      try {
        let a;
        const s = Object.assign(Object.assign({}, wh), r);
        let i = Object.assign(
          Object.assign({}, this.headers),
          t === "POST" && { "x-upsert": String(s.upsert) },
        );
        const l = s.metadata;
        typeof Blob < "u" && o instanceof Blob
          ? ((a = new FormData()),
            a.append("cacheControl", s.cacheControl),
            l && a.append("metadata", this.encodeMetadata(l)),
            a.append("", o))
          : typeof FormData < "u" && o instanceof FormData
            ? ((a = o),
              a.append("cacheControl", s.cacheControl),
              l && a.append("metadata", this.encodeMetadata(l)))
            : ((a = o),
              (i["cache-control"] = `max-age=${s.cacheControl}`),
              (i["content-type"] = s.contentType),
              l && (i["x-metadata"] = this.toBase64(this.encodeMetadata(l)))),
          r != null &&
            r.headers &&
            (i = Object.assign(Object.assign({}, i), r.headers));
        const c = this._removeEmptyFolders(n),
          u = this._getFinalPath(c),
          m = yield this.fetch(
            `${this.url}/object/${u}`,
            Object.assign(
              { method: t, body: a, headers: i },
              s != null && s.duplex ? { duplex: s.duplex } : {},
            ),
          ),
          p = yield m.json();
        return m.ok
          ? { data: { path: c, id: p.Id, fullPath: p.Key }, error: null }
          : { data: null, error: p };
      } catch (a) {
        if (Ee(a)) return { data: null, error: a };
        throw a;
      }
    });
  }
  upload(t, n, o) {
    return Ye(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("POST", t, n, o);
    });
  }
  uploadToSignedUrl(t, n, o, r) {
    return Ye(this, void 0, void 0, function* () {
      const a = this._removeEmptyFolders(t),
        s = this._getFinalPath(a),
        i = new URL(this.url + `/object/upload/sign/${s}`);
      i.searchParams.set("token", n);
      try {
        let l;
        const c = Object.assign({ upsert: wh.upsert }, r),
          u = Object.assign(Object.assign({}, this.headers), {
            "x-upsert": String(c.upsert),
          });
        typeof Blob < "u" && o instanceof Blob
          ? ((l = new FormData()),
            l.append("cacheControl", c.cacheControl),
            l.append("", o))
          : typeof FormData < "u" && o instanceof FormData
            ? ((l = o), l.append("cacheControl", c.cacheControl))
            : ((l = o),
              (u["cache-control"] = `max-age=${c.cacheControl}`),
              (u["content-type"] = c.contentType));
        const m = yield this.fetch(i.toString(), {
            method: "PUT",
            body: l,
            headers: u,
          }),
          p = yield m.json();
        return m.ok
          ? { data: { path: a, fullPath: p.Key }, error: null }
          : { data: null, error: p };
      } catch (l) {
        if (Ee(l)) return { data: null, error: l };
        throw l;
      }
    });
  }
  createSignedUploadUrl(t, n) {
    return Ye(this, void 0, void 0, function* () {
      try {
        let o = this._getFinalPath(t);
        const r = Object.assign({}, this.headers);
        n != null && n.upsert && (r["x-upsert"] = "true");
        const a = yield En(
            this.fetch,
            `${this.url}/object/upload/sign/${o}`,
            {},
            { headers: r },
          ),
          s = new URL(this.url + a.url),
          i = s.searchParams.get("token");
        if (!i) throw new Xm("No token returned by API");
        return {
          data: { signedUrl: s.toString(), path: t, token: i },
          error: null,
        };
      } catch (o) {
        if (Ee(o)) return { data: null, error: o };
        throw o;
      }
    });
  }
  update(t, n, o) {
    return Ye(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("PUT", t, n, o);
    });
  }
  move(t, n, o) {
    return Ye(this, void 0, void 0, function* () {
      try {
        return {
          data: yield En(
            this.fetch,
            `${this.url}/object/move`,
            {
              bucketId: this.bucketId,
              sourceKey: t,
              destinationKey: n,
              destinationBucket: o == null ? void 0 : o.destinationBucket,
            },
            { headers: this.headers },
          ),
          error: null,
        };
      } catch (r) {
        if (Ee(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  copy(t, n, o) {
    return Ye(this, void 0, void 0, function* () {
      try {
        return {
          data: {
            path: (yield En(
              this.fetch,
              `${this.url}/object/copy`,
              {
                bucketId: this.bucketId,
                sourceKey: t,
                destinationKey: n,
                destinationBucket: o == null ? void 0 : o.destinationBucket,
              },
              { headers: this.headers },
            )).Key,
          },
          error: null,
        };
      } catch (r) {
        if (Ee(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  createSignedUrl(t, n, o) {
    return Ye(this, void 0, void 0, function* () {
      try {
        let r = this._getFinalPath(t),
          a = yield En(
            this.fetch,
            `${this.url}/object/sign/${r}`,
            Object.assign(
              { expiresIn: n },
              o != null && o.transform ? { transform: o.transform } : {},
            ),
            { headers: this.headers },
          );
        const s =
          o != null && o.download
            ? `&download=${o.download === !0 ? "" : o.download}`
            : "";
        return (
          (a = { signedUrl: encodeURI(`${this.url}${a.signedURL}${s}`) }),
          { data: a, error: null }
        );
      } catch (r) {
        if (Ee(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  createSignedUrls(t, n, o) {
    return Ye(this, void 0, void 0, function* () {
      try {
        const r = yield En(
            this.fetch,
            `${this.url}/object/sign/${this.bucketId}`,
            { expiresIn: n, paths: t },
            { headers: this.headers },
          ),
          a =
            o != null && o.download
              ? `&download=${o.download === !0 ? "" : o.download}`
              : "";
        return {
          data: r.map((s) =>
            Object.assign(Object.assign({}, s), {
              signedUrl: s.signedURL
                ? encodeURI(`${this.url}${s.signedURL}${a}`)
                : null,
            }),
          ),
          error: null,
        };
      } catch (r) {
        if (Ee(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  download(t, n) {
    return Ye(this, void 0, void 0, function* () {
      const r =
          typeof (n == null ? void 0 : n.transform) < "u"
            ? "render/image/authenticated"
            : "object",
        a = this.transformOptsToQueryString(
          (n == null ? void 0 : n.transform) || {},
        ),
        s = a ? `?${a}` : "";
      try {
        const i = this._getFinalPath(t);
        return {
          data: yield (yield Xi(this.fetch, `${this.url}/${r}/${i}${s}`, {
            headers: this.headers,
            noResolveJson: !0,
          })).blob(),
          error: null,
        };
      } catch (i) {
        if (Ee(i)) return { data: null, error: i };
        throw i;
      }
    });
  }
  info(t) {
    return Ye(this, void 0, void 0, function* () {
      const n = this._getFinalPath(t);
      try {
        const o = yield Xi(this.fetch, `${this.url}/object/info/${n}`, {
          headers: this.headers,
        });
        return { data: lu(o), error: null };
      } catch (o) {
        if (Ee(o)) return { data: null, error: o };
        throw o;
      }
    });
  }
  exists(t) {
    return Ye(this, void 0, void 0, function* () {
      const n = this._getFinalPath(t);
      try {
        return (
          yield YN(this.fetch, `${this.url}/object/${n}`, {
            headers: this.headers,
          }),
          { data: !0, error: null }
        );
      } catch (o) {
        if (Ee(o) && o instanceof iu) {
          const r = o.originalError;
          if ([400, 404].includes(r == null ? void 0 : r.status))
            return { data: !1, error: o };
        }
        throw o;
      }
    });
  }
  getPublicUrl(t, n) {
    const o = this._getFinalPath(t),
      r = [],
      a =
        n != null && n.download
          ? `download=${n.download === !0 ? "" : n.download}`
          : "";
    a !== "" && r.push(a);
    const i =
        typeof (n == null ? void 0 : n.transform) < "u"
          ? "render/image"
          : "object",
      l = this.transformOptsToQueryString(
        (n == null ? void 0 : n.transform) || {},
      );
    l !== "" && r.push(l);
    let c = r.join("&");
    return (
      c !== "" && (c = `?${c}`),
      { data: { publicUrl: encodeURI(`${this.url}/${i}/public/${o}${c}`) } }
    );
  }
  remove(t) {
    return Ye(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Gy(
            this.fetch,
            `${this.url}/object/${this.bucketId}`,
            { prefixes: t },
            { headers: this.headers },
          ),
          error: null,
        };
      } catch (n) {
        if (Ee(n)) return { data: null, error: n };
        throw n;
      }
    });
  }
  list(t, n, o) {
    return Ye(this, void 0, void 0, function* () {
      try {
        const r = Object.assign(Object.assign(Object.assign({}, XN), n), {
          prefix: t || "",
        });
        return {
          data: yield En(
            this.fetch,
            `${this.url}/object/list/${this.bucketId}`,
            r,
            { headers: this.headers },
            o,
          ),
          error: null,
        };
      } catch (r) {
        if (Ee(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  encodeMetadata(t) {
    return JSON.stringify(t);
  }
  toBase64(t) {
    return typeof Buffer < "u" ? Buffer.from(t).toString("base64") : btoa(t);
  }
  _getFinalPath(t) {
    return `${this.bucketId}/${t}`;
  }
  _removeEmptyFolders(t) {
    return t.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
  }
  transformOptsToQueryString(t) {
    const n = [];
    return (
      t.width && n.push(`width=${t.width}`),
      t.height && n.push(`height=${t.height}`),
      t.resize && n.push(`resize=${t.resize}`),
      t.format && n.push(`format=${t.format}`),
      t.quality && n.push(`quality=${t.quality}`),
      n.join("&")
    );
  }
}
const eO = "2.7.1",
  tO = { "X-Client-Info": `storage-js/${eO}` };
var Go = function (e, t, n, o) {
  function r(a) {
    return a instanceof n
      ? a
      : new n(function (s) {
          s(a);
        });
  }
  return new (n || (n = Promise))(function (a, s) {
    function i(u) {
      try {
        c(o.next(u));
      } catch (m) {
        s(m);
      }
    }
    function l(u) {
      try {
        c(o.throw(u));
      } catch (m) {
        s(m);
      }
    }
    function c(u) {
      u.done ? a(u.value) : r(u.value).then(i, l);
    }
    c((o = o.apply(e, t || [])).next());
  });
};
class nO {
  constructor(t, n = {}, o) {
    (this.url = t),
      (this.headers = Object.assign(Object.assign({}, tO), n)),
      (this.fetch = Wy(o));
  }
  listBuckets() {
    return Go(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Xi(this.fetch, `${this.url}/bucket`, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (t) {
        if (Ee(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  getBucket(t) {
    return Go(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Xi(this.fetch, `${this.url}/bucket/${t}`, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (n) {
        if (Ee(n)) return { data: null, error: n };
        throw n;
      }
    });
  }
  createBucket(t, n = { public: !1 }) {
    return Go(this, void 0, void 0, function* () {
      try {
        return {
          data: yield En(
            this.fetch,
            `${this.url}/bucket`,
            {
              id: t,
              name: t,
              public: n.public,
              file_size_limit: n.fileSizeLimit,
              allowed_mime_types: n.allowedMimeTypes,
            },
            { headers: this.headers },
          ),
          error: null,
        };
      } catch (o) {
        if (Ee(o)) return { data: null, error: o };
        throw o;
      }
    });
  }
  updateBucket(t, n) {
    return Go(this, void 0, void 0, function* () {
      try {
        return {
          data: yield JN(
            this.fetch,
            `${this.url}/bucket/${t}`,
            {
              id: t,
              name: t,
              public: n.public,
              file_size_limit: n.fileSizeLimit,
              allowed_mime_types: n.allowedMimeTypes,
            },
            { headers: this.headers },
          ),
          error: null,
        };
      } catch (o) {
        if (Ee(o)) return { data: null, error: o };
        throw o;
      }
    });
  }
  emptyBucket(t) {
    return Go(this, void 0, void 0, function* () {
      try {
        return {
          data: yield En(
            this.fetch,
            `${this.url}/bucket/${t}/empty`,
            {},
            { headers: this.headers },
          ),
          error: null,
        };
      } catch (n) {
        if (Ee(n)) return { data: null, error: n };
        throw n;
      }
    });
  }
  deleteBucket(t) {
    return Go(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Gy(
            this.fetch,
            `${this.url}/bucket/${t}`,
            {},
            { headers: this.headers },
          ),
          error: null,
        };
      } catch (n) {
        if (Ee(n)) return { data: null, error: n };
        throw n;
      }
    });
  }
}
class oO extends nO {
  constructor(t, n = {}, o) {
    super(t, n, o);
  }
  from(t) {
    return new ZN(this.url, this.headers, t, this.fetch);
  }
}
const rO = "2.49.4";
let ya = "";
typeof Deno < "u"
  ? (ya = "deno")
  : typeof document < "u"
    ? (ya = "web")
    : typeof navigator < "u" && navigator.product === "ReactNative"
      ? (ya = "react-native")
      : (ya = "node");
const aO = { "X-Client-Info": `supabase-js-${ya}/${rO}` },
  sO = { headers: aO },
  iO = { schema: "public" },
  lO = {
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    flowType: "implicit",
  },
  cO = {};
var dO = function (e, t, n, o) {
  function r(a) {
    return a instanceof n
      ? a
      : new n(function (s) {
          s(a);
        });
  }
  return new (n || (n = Promise))(function (a, s) {
    function i(u) {
      try {
        c(o.next(u));
      } catch (m) {
        s(m);
      }
    }
    function l(u) {
      try {
        c(o.throw(u));
      } catch (m) {
        s(m);
      }
    }
    function c(u) {
      u.done ? a(u.value) : r(u.value).then(i, l);
    }
    c((o = o.apply(e, t || [])).next());
  });
};
const uO = (e) => {
    let t;
    return (
      e ? (t = e) : typeof fetch > "u" ? (t = Ey) : (t = fetch),
      (...n) => t(...n)
    );
  },
  mO = () => (typeof Headers > "u" ? Ny : Headers),
  pO = (e, t, n) => {
    const o = uO(n),
      r = mO();
    return (a, s) =>
      dO(void 0, void 0, void 0, function* () {
        var i;
        const l = (i = yield t()) !== null && i !== void 0 ? i : e;
        let c = new r(s == null ? void 0 : s.headers);
        return (
          c.has("apikey") || c.set("apikey", e),
          c.has("Authorization") || c.set("Authorization", `Bearer ${l}`),
          o(a, Object.assign(Object.assign({}, s), { headers: c }))
        );
      });
  };
var fO = function (e, t, n, o) {
  function r(a) {
    return a instanceof n
      ? a
      : new n(function (s) {
          s(a);
        });
  }
  return new (n || (n = Promise))(function (a, s) {
    function i(u) {
      try {
        c(o.next(u));
      } catch (m) {
        s(m);
      }
    }
    function l(u) {
      try {
        c(o.throw(u));
      } catch (m) {
        s(m);
      }
    }
    function c(u) {
      u.done ? a(u.value) : r(u.value).then(i, l);
    }
    c((o = o.apply(e, t || [])).next());
  });
};
function hO(e) {
  return e.replace(/\/$/, "");
}
function vO(e, t) {
  const { db: n, auth: o, realtime: r, global: a } = e,
    { db: s, auth: i, realtime: l, global: c } = t,
    u = {
      db: Object.assign(Object.assign({}, s), n),
      auth: Object.assign(Object.assign({}, i), o),
      realtime: Object.assign(Object.assign({}, l), r),
      global: Object.assign(Object.assign({}, c), a),
      accessToken: () =>
        fO(this, void 0, void 0, function* () {
          return "";
        }),
    };
  return (
    e.accessToken ? (u.accessToken = e.accessToken) : delete u.accessToken, u
  );
}
const Hy = "2.69.1",
  qo = 30 * 1e3,
  cu = 3,
  $c = cu * qo,
  gO = "http://localhost:9999",
  xO = "supabase.auth.token",
  yO = { "X-Client-Info": `gotrue-js/${Hy}` },
  du = "X-Supabase-Api-Version",
  Ky = {
    "2024-01-01": {
      timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
      name: "2024-01-01",
    },
  },
  wO = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i,
  SO = 6e5;
class Zm extends Error {
  constructor(t, n, o) {
    super(t),
      (this.__isAuthError = !0),
      (this.name = "AuthError"),
      (this.status = n),
      (this.code = o);
  }
}
function Z(e) {
  return typeof e == "object" && e !== null && "__isAuthError" in e;
}
class bO extends Zm {
  constructor(t, n, o) {
    super(t, n, o),
      (this.name = "AuthApiError"),
      (this.status = n),
      (this.code = o);
  }
}
function CO(e) {
  return Z(e) && e.name === "AuthApiError";
}
class qy extends Zm {
  constructor(t, n) {
    super(t), (this.name = "AuthUnknownError"), (this.originalError = n);
  }
}
class lo extends Zm {
  constructor(t, n, o, r) {
    super(t, o, r), (this.name = n), (this.status = o);
  }
}
class Pn extends lo {
  constructor() {
    super("Auth session missing!", "AuthSessionMissingError", 400, void 0);
  }
}
function kO(e) {
  return Z(e) && e.name === "AuthSessionMissingError";
}
class Fc extends lo {
  constructor() {
    super(
      "Auth session or user missing",
      "AuthInvalidTokenResponseError",
      500,
      void 0,
    );
  }
}
class Ys extends lo {
  constructor(t) {
    super(t, "AuthInvalidCredentialsError", 400, void 0);
  }
}
class Xs extends lo {
  constructor(t, n = null) {
    super(t, "AuthImplicitGrantRedirectError", 500, void 0),
      (this.details = null),
      (this.details = n);
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details,
    };
  }
}
function PO(e) {
  return Z(e) && e.name === "AuthImplicitGrantRedirectError";
}
class Sh extends lo {
  constructor(t, n = null) {
    super(t, "AuthPKCEGrantCodeExchangeError", 500, void 0),
      (this.details = null),
      (this.details = n);
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details,
    };
  }
}
class uu extends lo {
  constructor(t, n) {
    super(t, "AuthRetryableFetchError", n, void 0);
  }
}
function Uc(e) {
  return Z(e) && e.name === "AuthRetryableFetchError";
}
class bh extends lo {
  constructor(t, n, o) {
    super(t, "AuthWeakPasswordError", n, "weak_password"), (this.reasons = o);
  }
}
class Ia extends lo {
  constructor(t) {
    super(t, "AuthInvalidJwtError", 400, "invalid_jwt");
  }
}
const Ch =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(
      "",
    ),
  kh = ` 	
\r=`.split(""),
  _O = (() => {
    const e = new Array(128);
    for (let t = 0; t < e.length; t += 1) e[t] = -1;
    for (let t = 0; t < kh.length; t += 1) e[kh[t].charCodeAt(0)] = -2;
    for (let t = 0; t < Ch.length; t += 1) e[Ch[t].charCodeAt(0)] = t;
    return e;
  })();
function Qy(e, t, n) {
  const o = _O[e];
  if (o > -1)
    for (t.queue = (t.queue << 6) | o, t.queuedBits += 6; t.queuedBits >= 8; )
      n((t.queue >> (t.queuedBits - 8)) & 255), (t.queuedBits -= 8);
  else {
    if (o === -2) return;
    throw new Error(`Invalid Base64-URL character "${String.fromCharCode(e)}"`);
  }
}
function Ph(e) {
  const t = [],
    n = (s) => {
      t.push(String.fromCodePoint(s));
    },
    o = { utf8seq: 0, codepoint: 0 },
    r = { queue: 0, queuedBits: 0 },
    a = (s) => {
      EO(s, o, n);
    };
  for (let s = 0; s < e.length; s += 1) Qy(e.charCodeAt(s), r, a);
  return t.join("");
}
function AO(e, t) {
  if (e <= 127) {
    t(e);
    return;
  } else if (e <= 2047) {
    t(192 | (e >> 6)), t(128 | (e & 63));
    return;
  } else if (e <= 65535) {
    t(224 | (e >> 12)), t(128 | ((e >> 6) & 63)), t(128 | (e & 63));
    return;
  } else if (e <= 1114111) {
    t(240 | (e >> 18)),
      t(128 | ((e >> 12) & 63)),
      t(128 | ((e >> 6) & 63)),
      t(128 | (e & 63));
    return;
  }
  throw new Error(`Unrecognized Unicode codepoint: ${e.toString(16)}`);
}
function DO(e, t) {
  for (let n = 0; n < e.length; n += 1) {
    let o = e.charCodeAt(n);
    if (o > 55295 && o <= 56319) {
      const r = ((o - 55296) * 1024) & 65535;
      (o = (((e.charCodeAt(n + 1) - 56320) & 65535) | r) + 65536), (n += 1);
    }
    AO(o, t);
  }
}
function EO(e, t, n) {
  if (t.utf8seq === 0) {
    if (e <= 127) {
      n(e);
      return;
    }
    for (let o = 1; o < 6; o += 1)
      if (!((e >> (7 - o)) & 1)) {
        t.utf8seq = o;
        break;
      }
    if (t.utf8seq === 2) t.codepoint = e & 31;
    else if (t.utf8seq === 3) t.codepoint = e & 15;
    else if (t.utf8seq === 4) t.codepoint = e & 7;
    else throw new Error("Invalid UTF-8 sequence");
    t.utf8seq -= 1;
  } else if (t.utf8seq > 0) {
    if (e <= 127) throw new Error("Invalid UTF-8 sequence");
    (t.codepoint = (t.codepoint << 6) | (e & 63)),
      (t.utf8seq -= 1),
      t.utf8seq === 0 && n(t.codepoint);
  }
}
function NO(e) {
  const t = [],
    n = { queue: 0, queuedBits: 0 },
    o = (r) => {
      t.push(r);
    };
  for (let r = 0; r < e.length; r += 1) Qy(e.charCodeAt(r), n, o);
  return new Uint8Array(t);
}
function OO(e) {
  const t = [];
  return DO(e, (n) => t.push(n)), new Uint8Array(t);
}
function IO(e) {
  return Math.round(Date.now() / 1e3) + e;
}
function TO() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (e) {
    const t = (Math.random() * 16) | 0;
    return (e == "x" ? t : (t & 3) | 8).toString(16);
  });
}
const Vt = () => typeof window < "u" && typeof document < "u",
  co = { tested: !1, writable: !1 },
  Ta = () => {
    if (!Vt()) return !1;
    try {
      if (typeof globalThis.localStorage != "object") return !1;
    } catch {
      return !1;
    }
    if (co.tested) return co.writable;
    const e = `lswt-${Math.random()}${Math.random()}`;
    try {
      globalThis.localStorage.setItem(e, e),
        globalThis.localStorage.removeItem(e),
        (co.tested = !0),
        (co.writable = !0);
    } catch {
      (co.tested = !0), (co.writable = !1);
    }
    return co.writable;
  };
function jO(e) {
  const t = {},
    n = new URL(e);
  if (n.hash && n.hash[0] === "#")
    try {
      new URLSearchParams(n.hash.substring(1)).forEach((r, a) => {
        t[a] = r;
      });
    } catch {}
  return (
    n.searchParams.forEach((o, r) => {
      t[r] = o;
    }),
    t
  );
}
const Jy = (e) => {
    let t;
    return (
      e
        ? (t = e)
        : typeof fetch > "u"
          ? (t = (...n) =>
              Br(
                async () => {
                  const { default: o } = await Promise.resolve().then(() => Yr);
                  return { default: o };
                },
                void 0,
              ).then(({ default: o }) => o(...n)))
          : (t = fetch),
      (...n) => t(...n)
    );
  },
  RO = (e) =>
    typeof e == "object" &&
    e !== null &&
    "status" in e &&
    "ok" in e &&
    "json" in e &&
    typeof e.json == "function",
  Yy = async (e, t, n) => {
    await e.setItem(t, JSON.stringify(n));
  },
  Zs = async (e, t) => {
    const n = await e.getItem(t);
    if (!n) return null;
    try {
      return JSON.parse(n);
    } catch {
      return n;
    }
  },
  ei = async (e, t) => {
    await e.removeItem(t);
  };
class Gl {
  constructor() {
    this.promise = new Gl.promiseConstructor((t, n) => {
      (this.resolve = t), (this.reject = n);
    });
  }
}
Gl.promiseConstructor = Promise;
function zc(e) {
  const t = e.split(".");
  if (t.length !== 3) throw new Ia("Invalid JWT structure");
  for (let o = 0; o < t.length; o++)
    if (!wO.test(t[o])) throw new Ia("JWT not in base64url format");
  return {
    header: JSON.parse(Ph(t[0])),
    payload: JSON.parse(Ph(t[1])),
    signature: NO(t[2]),
    raw: { header: t[0], payload: t[1] },
  };
}
async function MO(e) {
  return await new Promise((t) => {
    setTimeout(() => t(null), e);
  });
}
function BO(e, t) {
  return new Promise((o, r) => {
    (async () => {
      for (let a = 0; a < 1 / 0; a++)
        try {
          const s = await e(a);
          if (!t(a, null, s)) {
            o(s);
            return;
          }
        } catch (s) {
          if (!t(a, s)) {
            r(s);
            return;
          }
        }
    })();
  });
}
function LO(e) {
  return ("0" + e.toString(16)).substr(-2);
}
function $O() {
  const t = new Uint32Array(56);
  if (typeof crypto > "u") {
    const n =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",
      o = n.length;
    let r = "";
    for (let a = 0; a < 56; a++) r += n.charAt(Math.floor(Math.random() * o));
    return r;
  }
  return crypto.getRandomValues(t), Array.from(t, LO).join("");
}
async function FO(e) {
  const n = new TextEncoder().encode(e),
    o = await crypto.subtle.digest("SHA-256", n),
    r = new Uint8Array(o);
  return Array.from(r)
    .map((a) => String.fromCharCode(a))
    .join("");
}
async function UO(e) {
  if (
    !(
      typeof crypto < "u" &&
      typeof crypto.subtle < "u" &&
      typeof TextEncoder < "u"
    )
  )
    return (
      console.warn(
        "WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.",
      ),
      e
    );
  const n = await FO(e);
  return btoa(n).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function Ho(e, t, n = !1) {
  const o = $O();
  let r = o;
  n && (r += "/PASSWORD_RECOVERY"), await Yy(e, `${t}-code-verifier`, r);
  const a = await UO(o);
  return [a, o === a ? "plain" : "s256"];
}
const zO = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function VO(e) {
  const t = e.headers.get(du);
  if (!t || !t.match(zO)) return null;
  try {
    return new Date(`${t}T00:00:00.0Z`);
  } catch {
    return null;
  }
}
function WO(e) {
  if (!e) throw new Error("Missing exp claim");
  const t = Math.floor(Date.now() / 1e3);
  if (e <= t) throw new Error("JWT has expired");
}
function GO(e) {
  switch (e) {
    case "RS256":
      return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } };
    case "ES256":
      return { name: "ECDSA", namedCurve: "P-256", hash: { name: "SHA-256" } };
    default:
      throw new Error("Invalid alg claim");
  }
}
var HO = function (e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) &&
      t.indexOf(o) < 0 &&
      (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, o[r]) &&
        (n[o[r]] = e[o[r]]);
  return n;
};
const fo = (e) =>
    e.msg || e.message || e.error_description || e.error || JSON.stringify(e),
  KO = [502, 503, 504];
async function _h(e) {
  var t;
  if (!RO(e)) throw new uu(fo(e), 0);
  if (KO.includes(e.status)) throw new uu(fo(e), e.status);
  let n;
  try {
    n = await e.json();
  } catch (a) {
    throw new qy(fo(a), a);
  }
  let o;
  const r = VO(e);
  if (
    (r &&
    r.getTime() >= Ky["2024-01-01"].timestamp &&
    typeof n == "object" &&
    n &&
    typeof n.code == "string"
      ? (o = n.code)
      : typeof n == "object" &&
        n &&
        typeof n.error_code == "string" &&
        (o = n.error_code),
    o)
  ) {
    if (o === "weak_password")
      throw new bh(
        fo(n),
        e.status,
        ((t = n.weak_password) === null || t === void 0 ? void 0 : t.reasons) ||
          [],
      );
    if (o === "session_not_found") throw new Pn();
  } else if (
    typeof n == "object" &&
    n &&
    typeof n.weak_password == "object" &&
    n.weak_password &&
    Array.isArray(n.weak_password.reasons) &&
    n.weak_password.reasons.length &&
    n.weak_password.reasons.reduce((a, s) => a && typeof s == "string", !0)
  )
    throw new bh(fo(n), e.status, n.weak_password.reasons);
  throw new bO(fo(n), e.status || 500, o);
}
const qO = (e, t, n, o) => {
  const r = { method: e, headers: (t == null ? void 0 : t.headers) || {} };
  return e === "GET"
    ? r
    : ((r.headers = Object.assign(
        { "Content-Type": "application/json;charset=UTF-8" },
        t == null ? void 0 : t.headers,
      )),
      (r.body = JSON.stringify(o)),
      Object.assign(Object.assign({}, r), n));
};
async function oe(e, t, n, o) {
  var r;
  const a = Object.assign({}, o == null ? void 0 : o.headers);
  a[du] || (a[du] = Ky["2024-01-01"].name),
    o != null && o.jwt && (a.Authorization = `Bearer ${o.jwt}`);
  const s =
    (r = o == null ? void 0 : o.query) !== null && r !== void 0 ? r : {};
  o != null && o.redirectTo && (s.redirect_to = o.redirectTo);
  const i = Object.keys(s).length
      ? "?" + new URLSearchParams(s).toString()
      : "",
    l = await QO(
      e,
      t,
      n + i,
      { headers: a, noResolveJson: o == null ? void 0 : o.noResolveJson },
      {},
      o == null ? void 0 : o.body,
    );
  return o != null && o.xform
    ? o == null
      ? void 0
      : o.xform(l)
    : { data: Object.assign({}, l), error: null };
}
async function QO(e, t, n, o, r, a) {
  const s = qO(t, o, r, a);
  let i;
  try {
    i = await e(n, Object.assign({}, s));
  } catch (l) {
    throw (console.error(l), new uu(fo(l), 0));
  }
  if ((i.ok || (await _h(i)), o != null && o.noResolveJson)) return i;
  try {
    return await i.json();
  } catch (l) {
    await _h(l);
  }
}
function _n(e) {
  var t;
  let n = null;
  ZO(e) &&
    ((n = Object.assign({}, e)),
    e.expires_at || (n.expires_at = IO(e.expires_in)));
  const o = (t = e.user) !== null && t !== void 0 ? t : e;
  return { data: { session: n, user: o }, error: null };
}
function Ah(e) {
  const t = _n(e);
  return (
    !t.error &&
      e.weak_password &&
      typeof e.weak_password == "object" &&
      Array.isArray(e.weak_password.reasons) &&
      e.weak_password.reasons.length &&
      e.weak_password.message &&
      typeof e.weak_password.message == "string" &&
      e.weak_password.reasons.reduce((n, o) => n && typeof o == "string", !0) &&
      (t.data.weak_password = e.weak_password),
    t
  );
}
function In(e) {
  var t;
  return {
    data: { user: (t = e.user) !== null && t !== void 0 ? t : e },
    error: null,
  };
}
function JO(e) {
  return { data: e, error: null };
}
function YO(e) {
  const {
      action_link: t,
      email_otp: n,
      hashed_token: o,
      redirect_to: r,
      verification_type: a,
    } = e,
    s = HO(e, [
      "action_link",
      "email_otp",
      "hashed_token",
      "redirect_to",
      "verification_type",
    ]),
    i = {
      action_link: t,
      email_otp: n,
      hashed_token: o,
      redirect_to: r,
      verification_type: a,
    },
    l = Object.assign({}, s);
  return { data: { properties: i, user: l }, error: null };
}
function XO(e) {
  return e;
}
function ZO(e) {
  return e.access_token && e.refresh_token && e.expires_in;
}
var eI = function (e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) &&
      t.indexOf(o) < 0 &&
      (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, o[r]) &&
        (n[o[r]] = e[o[r]]);
  return n;
};
class tI {
  constructor({ url: t = "", headers: n = {}, fetch: o }) {
    (this.url = t),
      (this.headers = n),
      (this.fetch = Jy(o)),
      (this.mfa = {
        listFactors: this._listFactors.bind(this),
        deleteFactor: this._deleteFactor.bind(this),
      });
  }
  async signOut(t, n = "global") {
    try {
      return (
        await oe(this.fetch, "POST", `${this.url}/logout?scope=${n}`, {
          headers: this.headers,
          jwt: t,
          noResolveJson: !0,
        }),
        { data: null, error: null }
      );
    } catch (o) {
      if (Z(o)) return { data: null, error: o };
      throw o;
    }
  }
  async inviteUserByEmail(t, n = {}) {
    try {
      return await oe(this.fetch, "POST", `${this.url}/invite`, {
        body: { email: t, data: n.data },
        headers: this.headers,
        redirectTo: n.redirectTo,
        xform: In,
      });
    } catch (o) {
      if (Z(o)) return { data: { user: null }, error: o };
      throw o;
    }
  }
  async generateLink(t) {
    try {
      const { options: n } = t,
        o = eI(t, ["options"]),
        r = Object.assign(Object.assign({}, o), n);
      return (
        "newEmail" in o &&
          ((r.new_email = o == null ? void 0 : o.newEmail), delete r.newEmail),
        await oe(this.fetch, "POST", `${this.url}/admin/generate_link`, {
          body: r,
          headers: this.headers,
          xform: YO,
          redirectTo: n == null ? void 0 : n.redirectTo,
        })
      );
    } catch (n) {
      if (Z(n)) return { data: { properties: null, user: null }, error: n };
      throw n;
    }
  }
  async createUser(t) {
    try {
      return await oe(this.fetch, "POST", `${this.url}/admin/users`, {
        body: t,
        headers: this.headers,
        xform: In,
      });
    } catch (n) {
      if (Z(n)) return { data: { user: null }, error: n };
      throw n;
    }
  }
  async listUsers(t) {
    var n, o, r, a, s, i, l;
    try {
      const c = { nextPage: null, lastPage: 0, total: 0 },
        u = await oe(this.fetch, "GET", `${this.url}/admin/users`, {
          headers: this.headers,
          noResolveJson: !0,
          query: {
            page:
              (o =
                (n = t == null ? void 0 : t.page) === null || n === void 0
                  ? void 0
                  : n.toString()) !== null && o !== void 0
                ? o
                : "",
            per_page:
              (a =
                (r = t == null ? void 0 : t.perPage) === null || r === void 0
                  ? void 0
                  : r.toString()) !== null && a !== void 0
                ? a
                : "",
          },
          xform: XO,
        });
      if (u.error) throw u.error;
      const m = await u.json(),
        p =
          (s = u.headers.get("x-total-count")) !== null && s !== void 0 ? s : 0,
        h =
          (l =
            (i = u.headers.get("link")) === null || i === void 0
              ? void 0
              : i.split(",")) !== null && l !== void 0
            ? l
            : [];
      return (
        h.length > 0 &&
          (h.forEach((g) => {
            const v = parseInt(g.split(";")[0].split("=")[1].substring(0, 1)),
              w = JSON.parse(g.split(";")[1].split("=")[1]);
            c[`${w}Page`] = v;
          }),
          (c.total = parseInt(p))),
        { data: Object.assign(Object.assign({}, m), c), error: null }
      );
    } catch (c) {
      if (Z(c)) return { data: { users: [] }, error: c };
      throw c;
    }
  }
  async getUserById(t) {
    try {
      return await oe(this.fetch, "GET", `${this.url}/admin/users/${t}`, {
        headers: this.headers,
        xform: In,
      });
    } catch (n) {
      if (Z(n)) return { data: { user: null }, error: n };
      throw n;
    }
  }
  async updateUserById(t, n) {
    try {
      return await oe(this.fetch, "PUT", `${this.url}/admin/users/${t}`, {
        body: n,
        headers: this.headers,
        xform: In,
      });
    } catch (o) {
      if (Z(o)) return { data: { user: null }, error: o };
      throw o;
    }
  }
  async deleteUser(t, n = !1) {
    try {
      return await oe(this.fetch, "DELETE", `${this.url}/admin/users/${t}`, {
        headers: this.headers,
        body: { should_soft_delete: n },
        xform: In,
      });
    } catch (o) {
      if (Z(o)) return { data: { user: null }, error: o };
      throw o;
    }
  }
  async _listFactors(t) {
    try {
      const { data: n, error: o } = await oe(
        this.fetch,
        "GET",
        `${this.url}/admin/users/${t.userId}/factors`,
        {
          headers: this.headers,
          xform: (r) => ({ data: { factors: r }, error: null }),
        },
      );
      return { data: n, error: o };
    } catch (n) {
      if (Z(n)) return { data: null, error: n };
      throw n;
    }
  }
  async _deleteFactor(t) {
    try {
      return {
        data: await oe(
          this.fetch,
          "DELETE",
          `${this.url}/admin/users/${t.userId}/factors/${t.id}`,
          { headers: this.headers },
        ),
        error: null,
      };
    } catch (n) {
      if (Z(n)) return { data: null, error: n };
      throw n;
    }
  }
}
const nI = {
  getItem: (e) => (Ta() ? globalThis.localStorage.getItem(e) : null),
  setItem: (e, t) => {
    Ta() && globalThis.localStorage.setItem(e, t);
  },
  removeItem: (e) => {
    Ta() && globalThis.localStorage.removeItem(e);
  },
};
function Dh(e = {}) {
  return {
    getItem: (t) => e[t] || null,
    setItem: (t, n) => {
      e[t] = n;
    },
    removeItem: (t) => {
      delete e[t];
    },
  };
}
function oI() {
  if (typeof globalThis != "object")
    try {
      Object.defineProperty(Object.prototype, "__magic__", {
        get: function () {
          return this;
        },
        configurable: !0,
      }),
        (__magic__.globalThis = __magic__),
        delete Object.prototype.__magic__;
    } catch {
      typeof self < "u" && (self.globalThis = self);
    }
}
const Ko = {
  debug: !!(
    globalThis &&
    Ta() &&
    globalThis.localStorage &&
    globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true"
  ),
};
class Xy extends Error {
  constructor(t) {
    super(t), (this.isAcquireTimeout = !0);
  }
}
class rI extends Xy {}
async function aI(e, t, n) {
  Ko.debug &&
    console.log("@supabase/gotrue-js: navigatorLock: acquire lock", e, t);
  const o = new globalThis.AbortController();
  return (
    t > 0 &&
      setTimeout(() => {
        o.abort(),
          Ko.debug &&
            console.log(
              "@supabase/gotrue-js: navigatorLock acquire timed out",
              e,
            );
      }, t),
    await Promise.resolve().then(() =>
      globalThis.navigator.locks.request(
        e,
        t === 0
          ? { mode: "exclusive", ifAvailable: !0 }
          : { mode: "exclusive", signal: o.signal },
        async (r) => {
          if (r) {
            Ko.debug &&
              console.log(
                "@supabase/gotrue-js: navigatorLock: acquired",
                e,
                r.name,
              );
            try {
              return await n();
            } finally {
              Ko.debug &&
                console.log(
                  "@supabase/gotrue-js: navigatorLock: released",
                  e,
                  r.name,
                );
            }
          } else {
            if (t === 0)
              throw (
                (Ko.debug &&
                  console.log(
                    "@supabase/gotrue-js: navigatorLock: not immediately available",
                    e,
                  ),
                new rI(
                  `Acquiring an exclusive Navigator LockManager lock "${e}" immediately failed`,
                ))
              );
            if (Ko.debug)
              try {
                const a = await globalThis.navigator.locks.query();
                console.log(
                  "@supabase/gotrue-js: Navigator LockManager state",
                  JSON.stringify(a, null, "  "),
                );
              } catch (a) {
                console.warn(
                  "@supabase/gotrue-js: Error when querying Navigator LockManager state",
                  a,
                );
              }
            return (
              console.warn(
                "@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request",
              ),
              await n()
            );
          }
        },
      ),
    )
  );
}
oI();
const sI = {
  url: gO,
  storageKey: xO,
  autoRefreshToken: !0,
  persistSession: !0,
  detectSessionInUrl: !0,
  headers: yO,
  flowType: "implicit",
  debug: !1,
  hasCustomAuthorizationHeader: !1,
};
async function Eh(e, t, n) {
  return await n();
}
class rs {
  constructor(t) {
    var n, o;
    (this.memoryStorage = null),
      (this.stateChangeEmitters = new Map()),
      (this.autoRefreshTicker = null),
      (this.visibilityChangedCallback = null),
      (this.refreshingDeferred = null),
      (this.initializePromise = null),
      (this.detectSessionInUrl = !0),
      (this.hasCustomAuthorizationHeader = !1),
      (this.suppressGetSessionWarning = !1),
      (this.lockAcquired = !1),
      (this.pendingInLock = []),
      (this.broadcastChannel = null),
      (this.logger = console.log),
      (this.instanceID = rs.nextInstanceID),
      (rs.nextInstanceID += 1),
      this.instanceID > 0 &&
        Vt() &&
        console.warn(
          "Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.",
        );
    const r = Object.assign(Object.assign({}, sI), t);
    if (
      ((this.logDebugMessages = !!r.debug),
      typeof r.debug == "function" && (this.logger = r.debug),
      (this.persistSession = r.persistSession),
      (this.storageKey = r.storageKey),
      (this.autoRefreshToken = r.autoRefreshToken),
      (this.admin = new tI({ url: r.url, headers: r.headers, fetch: r.fetch })),
      (this.url = r.url),
      (this.headers = r.headers),
      (this.fetch = Jy(r.fetch)),
      (this.lock = r.lock || Eh),
      (this.detectSessionInUrl = r.detectSessionInUrl),
      (this.flowType = r.flowType),
      (this.hasCustomAuthorizationHeader = r.hasCustomAuthorizationHeader),
      r.lock
        ? (this.lock = r.lock)
        : Vt() &&
            !(
              (n = globalThis == null ? void 0 : globalThis.navigator) ===
                null || n === void 0
            ) &&
            n.locks
          ? (this.lock = aI)
          : (this.lock = Eh),
      (this.jwks = { keys: [] }),
      (this.jwks_cached_at = Number.MIN_SAFE_INTEGER),
      (this.mfa = {
        verify: this._verify.bind(this),
        enroll: this._enroll.bind(this),
        unenroll: this._unenroll.bind(this),
        challenge: this._challenge.bind(this),
        listFactors: this._listFactors.bind(this),
        challengeAndVerify: this._challengeAndVerify.bind(this),
        getAuthenticatorAssuranceLevel:
          this._getAuthenticatorAssuranceLevel.bind(this),
      }),
      this.persistSession
        ? r.storage
          ? (this.storage = r.storage)
          : Ta()
            ? (this.storage = nI)
            : ((this.memoryStorage = {}),
              (this.storage = Dh(this.memoryStorage)))
        : ((this.memoryStorage = {}), (this.storage = Dh(this.memoryStorage))),
      Vt() &&
        globalThis.BroadcastChannel &&
        this.persistSession &&
        this.storageKey)
    ) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(
          this.storageKey,
        );
      } catch (a) {
        console.error(
          "Failed to create a new BroadcastChannel, multi-tab state changes will not be available",
          a,
        );
      }
      (o = this.broadcastChannel) === null ||
        o === void 0 ||
        o.addEventListener("message", async (a) => {
          this._debug(
            "received broadcast notification from other tab or client",
            a,
          ),
            await this._notifyAllSubscribers(a.data.event, a.data.session, !1);
        });
    }
    this.initialize();
  }
  _debug(...t) {
    return (
      this.logDebugMessages &&
        this.logger(
          `GoTrueClient@${this.instanceID} (${Hy}) ${new Date().toISOString()}`,
          ...t,
        ),
      this
    );
  }
  async initialize() {
    return this.initializePromise
      ? await this.initializePromise
      : ((this.initializePromise = (async () =>
          await this._acquireLock(-1, async () => await this._initialize()))()),
        await this.initializePromise);
  }
  async _initialize() {
    var t;
    try {
      const n = jO(window.location.href);
      let o = "none";
      if (
        (this._isImplicitGrantCallback(n)
          ? (o = "implicit")
          : (await this._isPKCECallback(n)) && (o = "pkce"),
        Vt() && this.detectSessionInUrl && o !== "none")
      ) {
        const { data: r, error: a } = await this._getSessionFromURL(n, o);
        if (a) {
          if (
            (this._debug(
              "#_initialize()",
              "error detecting session from URL",
              a,
            ),
            PO(a))
          ) {
            const l =
              (t = a.details) === null || t === void 0 ? void 0 : t.code;
            if (
              l === "identity_already_exists" ||
              l === "identity_not_found" ||
              l === "single_identity_not_deletable"
            )
              return { error: a };
          }
          return await this._removeSession(), { error: a };
        }
        const { session: s, redirectType: i } = r;
        return (
          this._debug(
            "#_initialize()",
            "detected session in URL",
            s,
            "redirect type",
            i,
          ),
          await this._saveSession(s),
          setTimeout(async () => {
            i === "recovery"
              ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", s)
              : await this._notifyAllSubscribers("SIGNED_IN", s);
          }, 0),
          { error: null }
        );
      }
      return await this._recoverAndRefresh(), { error: null };
    } catch (n) {
      return Z(n)
        ? { error: n }
        : { error: new qy("Unexpected error during initialization", n) };
    } finally {
      await this._handleVisibilityChange(),
        this._debug("#_initialize()", "end");
    }
  }
  async signInAnonymously(t) {
    var n, o, r;
    try {
      const a = await oe(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            data:
              (o =
                (n = t == null ? void 0 : t.options) === null || n === void 0
                  ? void 0
                  : n.data) !== null && o !== void 0
                ? o
                : {},
            gotrue_meta_security: {
              captcha_token:
                (r = t == null ? void 0 : t.options) === null || r === void 0
                  ? void 0
                  : r.captchaToken,
            },
          },
          xform: _n,
        }),
        { data: s, error: i } = a;
      if (i || !s) return { data: { user: null, session: null }, error: i };
      const l = s.session,
        c = s.user;
      return (
        s.session &&
          (await this._saveSession(s.session),
          await this._notifyAllSubscribers("SIGNED_IN", l)),
        { data: { user: c, session: l }, error: null }
      );
    } catch (a) {
      if (Z(a)) return { data: { user: null, session: null }, error: a };
      throw a;
    }
  }
  async signUp(t) {
    var n, o, r;
    try {
      let a;
      if ("email" in t) {
        const { email: u, password: m, options: p } = t;
        let h = null,
          g = null;
        this.flowType === "pkce" &&
          ([h, g] = await Ho(this.storage, this.storageKey)),
          (a = await oe(this.fetch, "POST", `${this.url}/signup`, {
            headers: this.headers,
            redirectTo: p == null ? void 0 : p.emailRedirectTo,
            body: {
              email: u,
              password: m,
              data:
                (n = p == null ? void 0 : p.data) !== null && n !== void 0
                  ? n
                  : {},
              gotrue_meta_security: {
                captcha_token: p == null ? void 0 : p.captchaToken,
              },
              code_challenge: h,
              code_challenge_method: g,
            },
            xform: _n,
          }));
      } else if ("phone" in t) {
        const { phone: u, password: m, options: p } = t;
        a = await oe(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            phone: u,
            password: m,
            data:
              (o = p == null ? void 0 : p.data) !== null && o !== void 0
                ? o
                : {},
            channel:
              (r = p == null ? void 0 : p.channel) !== null && r !== void 0
                ? r
                : "sms",
            gotrue_meta_security: {
              captcha_token: p == null ? void 0 : p.captchaToken,
            },
          },
          xform: _n,
        });
      } else
        throw new Ys(
          "You must provide either an email or phone number and a password",
        );
      const { data: s, error: i } = a;
      if (i || !s) return { data: { user: null, session: null }, error: i };
      const l = s.session,
        c = s.user;
      return (
        s.session &&
          (await this._saveSession(s.session),
          await this._notifyAllSubscribers("SIGNED_IN", l)),
        { data: { user: c, session: l }, error: null }
      );
    } catch (a) {
      if (Z(a)) return { data: { user: null, session: null }, error: a };
      throw a;
    }
  }
  async signInWithPassword(t) {
    try {
      let n;
      if ("email" in t) {
        const { email: a, password: s, options: i } = t;
        n = await oe(
          this.fetch,
          "POST",
          `${this.url}/token?grant_type=password`,
          {
            headers: this.headers,
            body: {
              email: a,
              password: s,
              gotrue_meta_security: {
                captcha_token: i == null ? void 0 : i.captchaToken,
              },
            },
            xform: Ah,
          },
        );
      } else if ("phone" in t) {
        const { phone: a, password: s, options: i } = t;
        n = await oe(
          this.fetch,
          "POST",
          `${this.url}/token?grant_type=password`,
          {
            headers: this.headers,
            body: {
              phone: a,
              password: s,
              gotrue_meta_security: {
                captcha_token: i == null ? void 0 : i.captchaToken,
              },
            },
            xform: Ah,
          },
        );
      } else
        throw new Ys(
          "You must provide either an email or phone number and a password",
        );
      const { data: o, error: r } = n;
      return r
        ? { data: { user: null, session: null }, error: r }
        : !o || !o.session || !o.user
          ? { data: { user: null, session: null }, error: new Fc() }
          : (o.session &&
              (await this._saveSession(o.session),
              await this._notifyAllSubscribers("SIGNED_IN", o.session)),
            {
              data: Object.assign(
                { user: o.user, session: o.session },
                o.weak_password ? { weakPassword: o.weak_password } : null,
              ),
              error: r,
            });
    } catch (n) {
      if (Z(n)) return { data: { user: null, session: null }, error: n };
      throw n;
    }
  }
  async signInWithOAuth(t) {
    var n, o, r, a;
    return await this._handleProviderSignIn(t.provider, {
      redirectTo:
        (n = t.options) === null || n === void 0 ? void 0 : n.redirectTo,
      scopes: (o = t.options) === null || o === void 0 ? void 0 : o.scopes,
      queryParams:
        (r = t.options) === null || r === void 0 ? void 0 : r.queryParams,
      skipBrowserRedirect:
        (a = t.options) === null || a === void 0
          ? void 0
          : a.skipBrowserRedirect,
    });
  }
  async exchangeCodeForSession(t) {
    return (
      await this.initializePromise,
      this._acquireLock(-1, async () => this._exchangeCodeForSession(t))
    );
  }
  async _exchangeCodeForSession(t) {
    const n = await Zs(this.storage, `${this.storageKey}-code-verifier`),
      [o, r] = (n ?? "").split("/");
    try {
      const { data: a, error: s } = await oe(
        this.fetch,
        "POST",
        `${this.url}/token?grant_type=pkce`,
        {
          headers: this.headers,
          body: { auth_code: t, code_verifier: o },
          xform: _n,
        },
      );
      if ((await ei(this.storage, `${this.storageKey}-code-verifier`), s))
        throw s;
      return !a || !a.session || !a.user
        ? {
            data: { user: null, session: null, redirectType: null },
            error: new Fc(),
          }
        : (a.session &&
            (await this._saveSession(a.session),
            await this._notifyAllSubscribers("SIGNED_IN", a.session)),
          {
            data: Object.assign(Object.assign({}, a), {
              redirectType: r ?? null,
            }),
            error: s,
          });
    } catch (a) {
      if (Z(a))
        return {
          data: { user: null, session: null, redirectType: null },
          error: a,
        };
      throw a;
    }
  }
  async signInWithIdToken(t) {
    try {
      const {
          options: n,
          provider: o,
          token: r,
          access_token: a,
          nonce: s,
        } = t,
        i = await oe(
          this.fetch,
          "POST",
          `${this.url}/token?grant_type=id_token`,
          {
            headers: this.headers,
            body: {
              provider: o,
              id_token: r,
              access_token: a,
              nonce: s,
              gotrue_meta_security: {
                captcha_token: n == null ? void 0 : n.captchaToken,
              },
            },
            xform: _n,
          },
        ),
        { data: l, error: c } = i;
      return c
        ? { data: { user: null, session: null }, error: c }
        : !l || !l.session || !l.user
          ? { data: { user: null, session: null }, error: new Fc() }
          : (l.session &&
              (await this._saveSession(l.session),
              await this._notifyAllSubscribers("SIGNED_IN", l.session)),
            { data: l, error: c });
    } catch (n) {
      if (Z(n)) return { data: { user: null, session: null }, error: n };
      throw n;
    }
  }
  async signInWithOtp(t) {
    var n, o, r, a, s;
    try {
      if ("email" in t) {
        const { email: i, options: l } = t;
        let c = null,
          u = null;
        this.flowType === "pkce" &&
          ([c, u] = await Ho(this.storage, this.storageKey));
        const { error: m } = await oe(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            email: i,
            data:
              (n = l == null ? void 0 : l.data) !== null && n !== void 0
                ? n
                : {},
            create_user:
              (o = l == null ? void 0 : l.shouldCreateUser) !== null &&
              o !== void 0
                ? o
                : !0,
            gotrue_meta_security: {
              captcha_token: l == null ? void 0 : l.captchaToken,
            },
            code_challenge: c,
            code_challenge_method: u,
          },
          redirectTo: l == null ? void 0 : l.emailRedirectTo,
        });
        return { data: { user: null, session: null }, error: m };
      }
      if ("phone" in t) {
        const { phone: i, options: l } = t,
          { data: c, error: u } = await oe(
            this.fetch,
            "POST",
            `${this.url}/otp`,
            {
              headers: this.headers,
              body: {
                phone: i,
                data:
                  (r = l == null ? void 0 : l.data) !== null && r !== void 0
                    ? r
                    : {},
                create_user:
                  (a = l == null ? void 0 : l.shouldCreateUser) !== null &&
                  a !== void 0
                    ? a
                    : !0,
                gotrue_meta_security: {
                  captcha_token: l == null ? void 0 : l.captchaToken,
                },
                channel:
                  (s = l == null ? void 0 : l.channel) !== null && s !== void 0
                    ? s
                    : "sms",
              },
            },
          );
        return {
          data: {
            user: null,
            session: null,
            messageId: c == null ? void 0 : c.message_id,
          },
          error: u,
        };
      }
      throw new Ys("You must provide either an email or phone number.");
    } catch (i) {
      if (Z(i)) return { data: { user: null, session: null }, error: i };
      throw i;
    }
  }
  async verifyOtp(t) {
    var n, o;
    try {
      let r, a;
      "options" in t &&
        ((r = (n = t.options) === null || n === void 0 ? void 0 : n.redirectTo),
        (a =
          (o = t.options) === null || o === void 0 ? void 0 : o.captchaToken));
      const { data: s, error: i } = await oe(
        this.fetch,
        "POST",
        `${this.url}/verify`,
        {
          headers: this.headers,
          body: Object.assign(Object.assign({}, t), {
            gotrue_meta_security: { captcha_token: a },
          }),
          redirectTo: r,
          xform: _n,
        },
      );
      if (i) throw i;
      if (!s) throw new Error("An error occurred on token verification.");
      const l = s.session,
        c = s.user;
      return (
        l != null &&
          l.access_token &&
          (await this._saveSession(l),
          await this._notifyAllSubscribers(
            t.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN",
            l,
          )),
        { data: { user: c, session: l }, error: null }
      );
    } catch (r) {
      if (Z(r)) return { data: { user: null, session: null }, error: r };
      throw r;
    }
  }
  async signInWithSSO(t) {
    var n, o, r;
    try {
      let a = null,
        s = null;
      return (
        this.flowType === "pkce" &&
          ([a, s] = await Ho(this.storage, this.storageKey)),
        await oe(this.fetch, "POST", `${this.url}/sso`, {
          body: Object.assign(
            Object.assign(
              Object.assign(
                Object.assign(
                  Object.assign(
                    {},
                    "providerId" in t ? { provider_id: t.providerId } : null,
                  ),
                  "domain" in t ? { domain: t.domain } : null,
                ),
                {
                  redirect_to:
                    (o =
                      (n = t.options) === null || n === void 0
                        ? void 0
                        : n.redirectTo) !== null && o !== void 0
                      ? o
                      : void 0,
                },
              ),
              !(
                (r = t == null ? void 0 : t.options) === null || r === void 0
              ) && r.captchaToken
                ? {
                    gotrue_meta_security: {
                      captcha_token: t.options.captchaToken,
                    },
                  }
                : null,
            ),
            {
              skip_http_redirect: !0,
              code_challenge: a,
              code_challenge_method: s,
            },
          ),
          headers: this.headers,
          xform: JO,
        })
      );
    } catch (a) {
      if (Z(a)) return { data: null, error: a };
      throw a;
    }
  }
  async reauthenticate() {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._reauthenticate())
    );
  }
  async _reauthenticate() {
    try {
      return await this._useSession(async (t) => {
        const {
          data: { session: n },
          error: o,
        } = t;
        if (o) throw o;
        if (!n) throw new Pn();
        const { error: r } = await oe(
          this.fetch,
          "GET",
          `${this.url}/reauthenticate`,
          { headers: this.headers, jwt: n.access_token },
        );
        return { data: { user: null, session: null }, error: r };
      });
    } catch (t) {
      if (Z(t)) return { data: { user: null, session: null }, error: t };
      throw t;
    }
  }
  async resend(t) {
    try {
      const n = `${this.url}/resend`;
      if ("email" in t) {
        const { email: o, type: r, options: a } = t,
          { error: s } = await oe(this.fetch, "POST", n, {
            headers: this.headers,
            body: {
              email: o,
              type: r,
              gotrue_meta_security: {
                captcha_token: a == null ? void 0 : a.captchaToken,
              },
            },
            redirectTo: a == null ? void 0 : a.emailRedirectTo,
          });
        return { data: { user: null, session: null }, error: s };
      } else if ("phone" in t) {
        const { phone: o, type: r, options: a } = t,
          { data: s, error: i } = await oe(this.fetch, "POST", n, {
            headers: this.headers,
            body: {
              phone: o,
              type: r,
              gotrue_meta_security: {
                captcha_token: a == null ? void 0 : a.captchaToken,
              },
            },
          });
        return {
          data: {
            user: null,
            session: null,
            messageId: s == null ? void 0 : s.message_id,
          },
          error: i,
        };
      }
      throw new Ys(
        "You must provide either an email or phone number and a type",
      );
    } catch (n) {
      if (Z(n)) return { data: { user: null, session: null }, error: n };
      throw n;
    }
  }
  async getSession() {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => this._useSession(async (n) => n))
    );
  }
  async _acquireLock(t, n) {
    this._debug("#_acquireLock", "begin", t);
    try {
      if (this.lockAcquired) {
        const o = this.pendingInLock.length
            ? this.pendingInLock[this.pendingInLock.length - 1]
            : Promise.resolve(),
          r = (async () => (await o, await n()))();
        return (
          this.pendingInLock.push(
            (async () => {
              try {
                await r;
              } catch {}
            })(),
          ),
          r
        );
      }
      return await this.lock(`lock:${this.storageKey}`, t, async () => {
        this._debug(
          "#_acquireLock",
          "lock acquired for storage key",
          this.storageKey,
        );
        try {
          this.lockAcquired = !0;
          const o = n();
          for (
            this.pendingInLock.push(
              (async () => {
                try {
                  await o;
                } catch {}
              })(),
            ),
              await o;
            this.pendingInLock.length;

          ) {
            const r = [...this.pendingInLock];
            await Promise.all(r), this.pendingInLock.splice(0, r.length);
          }
          return await o;
        } finally {
          this._debug(
            "#_acquireLock",
            "lock released for storage key",
            this.storageKey,
          ),
            (this.lockAcquired = !1);
        }
      });
    } finally {
      this._debug("#_acquireLock", "end");
    }
  }
  async _useSession(t) {
    this._debug("#_useSession", "begin");
    try {
      const n = await this.__loadSession();
      return await t(n);
    } finally {
      this._debug("#_useSession", "end");
    }
  }
  async __loadSession() {
    this._debug("#__loadSession()", "begin"),
      this.lockAcquired ||
        this._debug(
          "#__loadSession()",
          "used outside of an acquired lock!",
          new Error().stack,
        );
    try {
      let t = null;
      const n = await Zs(this.storage, this.storageKey);
      if (
        (this._debug("#getSession()", "session from storage", n),
        n !== null &&
          (this._isValidSession(n)
            ? (t = n)
            : (this._debug(
                "#getSession()",
                "session from storage is not valid",
              ),
              await this._removeSession())),
        !t)
      )
        return { data: { session: null }, error: null };
      const o = t.expires_at ? t.expires_at * 1e3 - Date.now() < $c : !1;
      if (
        (this._debug(
          "#__loadSession()",
          `session has${o ? "" : " not"} expired`,
          "expires_at",
          t.expires_at,
        ),
        !o)
      ) {
        if (this.storage.isServer) {
          let s = this.suppressGetSessionWarning;
          t = new Proxy(t, {
            get: (l, c, u) => (
              !s &&
                c === "user" &&
                (console.warn(
                  "Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.",
                ),
                (s = !0),
                (this.suppressGetSessionWarning = !0)),
              Reflect.get(l, c, u)
            ),
          });
        }
        return { data: { session: t }, error: null };
      }
      const { session: r, error: a } = await this._callRefreshToken(
        t.refresh_token,
      );
      return a
        ? { data: { session: null }, error: a }
        : { data: { session: r }, error: null };
    } finally {
      this._debug("#__loadSession()", "end");
    }
  }
  async getUser(t) {
    return t
      ? await this._getUser(t)
      : (await this.initializePromise,
        await this._acquireLock(-1, async () => await this._getUser()));
  }
  async _getUser(t) {
    try {
      return t
        ? await oe(this.fetch, "GET", `${this.url}/user`, {
            headers: this.headers,
            jwt: t,
            xform: In,
          })
        : await this._useSession(async (n) => {
            var o, r, a;
            const { data: s, error: i } = n;
            if (i) throw i;
            return !(
              !((o = s.session) === null || o === void 0) && o.access_token
            ) && !this.hasCustomAuthorizationHeader
              ? { data: { user: null }, error: new Pn() }
              : await oe(this.fetch, "GET", `${this.url}/user`, {
                  headers: this.headers,
                  jwt:
                    (a =
                      (r = s.session) === null || r === void 0
                        ? void 0
                        : r.access_token) !== null && a !== void 0
                      ? a
                      : void 0,
                  xform: In,
                });
          });
    } catch (n) {
      if (Z(n))
        return (
          kO(n) &&
            (await this._removeSession(),
            await ei(this.storage, `${this.storageKey}-code-verifier`)),
          { data: { user: null }, error: n }
        );
      throw n;
    }
  }
  async updateUser(t, n = {}) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._updateUser(t, n))
    );
  }
  async _updateUser(t, n = {}) {
    try {
      return await this._useSession(async (o) => {
        const { data: r, error: a } = o;
        if (a) throw a;
        if (!r.session) throw new Pn();
        const s = r.session;
        let i = null,
          l = null;
        this.flowType === "pkce" &&
          t.email != null &&
          ([i, l] = await Ho(this.storage, this.storageKey));
        const { data: c, error: u } = await oe(
          this.fetch,
          "PUT",
          `${this.url}/user`,
          {
            headers: this.headers,
            redirectTo: n == null ? void 0 : n.emailRedirectTo,
            body: Object.assign(Object.assign({}, t), {
              code_challenge: i,
              code_challenge_method: l,
            }),
            jwt: s.access_token,
            xform: In,
          },
        );
        if (u) throw u;
        return (
          (s.user = c.user),
          await this._saveSession(s),
          await this._notifyAllSubscribers("USER_UPDATED", s),
          { data: { user: s.user }, error: null }
        );
      });
    } catch (o) {
      if (Z(o)) return { data: { user: null }, error: o };
      throw o;
    }
  }
  async setSession(t) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._setSession(t))
    );
  }
  async _setSession(t) {
    try {
      if (!t.access_token || !t.refresh_token) throw new Pn();
      const n = Date.now() / 1e3;
      let o = n,
        r = !0,
        a = null;
      const { payload: s } = zc(t.access_token);
      if ((s.exp && ((o = s.exp), (r = o <= n)), r)) {
        const { session: i, error: l } = await this._callRefreshToken(
          t.refresh_token,
        );
        if (l) return { data: { user: null, session: null }, error: l };
        if (!i) return { data: { user: null, session: null }, error: null };
        a = i;
      } else {
        const { data: i, error: l } = await this._getUser(t.access_token);
        if (l) throw l;
        (a = {
          access_token: t.access_token,
          refresh_token: t.refresh_token,
          user: i.user,
          token_type: "bearer",
          expires_in: o - n,
          expires_at: o,
        }),
          await this._saveSession(a),
          await this._notifyAllSubscribers("SIGNED_IN", a);
      }
      return { data: { user: a.user, session: a }, error: null };
    } catch (n) {
      if (Z(n)) return { data: { session: null, user: null }, error: n };
      throw n;
    }
  }
  async refreshSession(t) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._refreshSession(t))
    );
  }
  async _refreshSession(t) {
    try {
      return await this._useSession(async (n) => {
        var o;
        if (!t) {
          const { data: s, error: i } = n;
          if (i) throw i;
          t = (o = s.session) !== null && o !== void 0 ? o : void 0;
        }
        if (!(t != null && t.refresh_token)) throw new Pn();
        const { session: r, error: a } = await this._callRefreshToken(
          t.refresh_token,
        );
        return a
          ? { data: { user: null, session: null }, error: a }
          : r
            ? { data: { user: r.user, session: r }, error: null }
            : { data: { user: null, session: null }, error: null };
      });
    } catch (n) {
      if (Z(n)) return { data: { user: null, session: null }, error: n };
      throw n;
    }
  }
  async _getSessionFromURL(t, n) {
    try {
      if (!Vt()) throw new Xs("No browser detected.");
      if (t.error || t.error_description || t.error_code)
        throw new Xs(
          t.error_description ||
            "Error in URL with unspecified error_description",
          {
            error: t.error || "unspecified_error",
            code: t.error_code || "unspecified_code",
          },
        );
      switch (n) {
        case "implicit":
          if (this.flowType === "pkce")
            throw new Sh("Not a valid PKCE flow url.");
          break;
        case "pkce":
          if (this.flowType === "implicit")
            throw new Xs("Not a valid implicit grant flow url.");
          break;
        default:
      }
      if (n === "pkce") {
        if (
          (this._debug("#_initialize()", "begin", "is PKCE flow", !0), !t.code)
        )
          throw new Sh("No code detected.");
        const { data: x, error: S } = await this._exchangeCodeForSession(
          t.code,
        );
        if (S) throw S;
        const b = new URL(window.location.href);
        return (
          b.searchParams.delete("code"),
          window.history.replaceState(window.history.state, "", b.toString()),
          { data: { session: x.session, redirectType: null }, error: null }
        );
      }
      const {
        provider_token: o,
        provider_refresh_token: r,
        access_token: a,
        refresh_token: s,
        expires_in: i,
        expires_at: l,
        token_type: c,
      } = t;
      if (!a || !i || !s || !c) throw new Xs("No session defined in URL");
      const u = Math.round(Date.now() / 1e3),
        m = parseInt(i);
      let p = u + m;
      l && (p = parseInt(l));
      const h = p - u;
      h * 1e3 <= qo &&
        console.warn(
          `@supabase/gotrue-js: Session as retrieved from URL expires in ${h}s, should have been closer to ${m}s`,
        );
      const g = p - m;
      u - g >= 120
        ? console.warn(
            "@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale",
            g,
            p,
            u,
          )
        : u - g < 0 &&
          console.warn(
            "@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew",
            g,
            p,
            u,
          );
      const { data: v, error: w } = await this._getUser(a);
      if (w) throw w;
      const y = {
        provider_token: o,
        provider_refresh_token: r,
        access_token: a,
        expires_in: m,
        expires_at: p,
        refresh_token: s,
        token_type: c,
        user: v.user,
      };
      return (
        (window.location.hash = ""),
        this._debug("#_getSessionFromURL()", "clearing window.location.hash"),
        { data: { session: y, redirectType: t.type }, error: null }
      );
    } catch (o) {
      if (Z(o))
        return { data: { session: null, redirectType: null }, error: o };
      throw o;
    }
  }
  _isImplicitGrantCallback(t) {
    return !!(t.access_token || t.error_description);
  }
  async _isPKCECallback(t) {
    const n = await Zs(this.storage, `${this.storageKey}-code-verifier`);
    return !!(t.code && n);
  }
  async signOut(t = { scope: "global" }) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._signOut(t))
    );
  }
  async _signOut({ scope: t } = { scope: "global" }) {
    return await this._useSession(async (n) => {
      var o;
      const { data: r, error: a } = n;
      if (a) return { error: a };
      const s =
        (o = r.session) === null || o === void 0 ? void 0 : o.access_token;
      if (s) {
        const { error: i } = await this.admin.signOut(s, t);
        if (
          i &&
          !(CO(i) && (i.status === 404 || i.status === 401 || i.status === 403))
        )
          return { error: i };
      }
      return (
        t !== "others" &&
          (await this._removeSession(),
          await ei(this.storage, `${this.storageKey}-code-verifier`)),
        { error: null }
      );
    });
  }
  onAuthStateChange(t) {
    const n = TO(),
      o = {
        id: n,
        callback: t,
        unsubscribe: () => {
          this._debug(
            "#unsubscribe()",
            "state change callback with id removed",
            n,
          ),
            this.stateChangeEmitters.delete(n);
        },
      };
    return (
      this._debug("#onAuthStateChange()", "registered callback with id", n),
      this.stateChangeEmitters.set(n, o),
      (async () => (
        await this.initializePromise,
        await this._acquireLock(-1, async () => {
          this._emitInitialSession(n);
        })
      ))(),
      { data: { subscription: o } }
    );
  }
  async _emitInitialSession(t) {
    return await this._useSession(async (n) => {
      var o, r;
      try {
        const {
          data: { session: a },
          error: s,
        } = n;
        if (s) throw s;
        await ((o = this.stateChangeEmitters.get(t)) === null || o === void 0
          ? void 0
          : o.callback("INITIAL_SESSION", a)),
          this._debug("INITIAL_SESSION", "callback id", t, "session", a);
      } catch (a) {
        await ((r = this.stateChangeEmitters.get(t)) === null || r === void 0
          ? void 0
          : r.callback("INITIAL_SESSION", null)),
          this._debug("INITIAL_SESSION", "callback id", t, "error", a),
          console.error(a);
      }
    });
  }
  async resetPasswordForEmail(t, n = {}) {
    let o = null,
      r = null;
    this.flowType === "pkce" &&
      ([o, r] = await Ho(this.storage, this.storageKey, !0));
    try {
      return await oe(this.fetch, "POST", `${this.url}/recover`, {
        body: {
          email: t,
          code_challenge: o,
          code_challenge_method: r,
          gotrue_meta_security: { captcha_token: n.captchaToken },
        },
        headers: this.headers,
        redirectTo: n.redirectTo,
      });
    } catch (a) {
      if (Z(a)) return { data: null, error: a };
      throw a;
    }
  }
  async getUserIdentities() {
    var t;
    try {
      const { data: n, error: o } = await this.getUser();
      if (o) throw o;
      return {
        data: {
          identities: (t = n.user.identities) !== null && t !== void 0 ? t : [],
        },
        error: null,
      };
    } catch (n) {
      if (Z(n)) return { data: null, error: n };
      throw n;
    }
  }
  async linkIdentity(t) {
    var n;
    try {
      const { data: o, error: r } = await this._useSession(async (a) => {
        var s, i, l, c, u;
        const { data: m, error: p } = a;
        if (p) throw p;
        const h = await this._getUrlForProvider(
          `${this.url}/user/identities/authorize`,
          t.provider,
          {
            redirectTo:
              (s = t.options) === null || s === void 0 ? void 0 : s.redirectTo,
            scopes:
              (i = t.options) === null || i === void 0 ? void 0 : i.scopes,
            queryParams:
              (l = t.options) === null || l === void 0 ? void 0 : l.queryParams,
            skipBrowserRedirect: !0,
          },
        );
        return await oe(this.fetch, "GET", h, {
          headers: this.headers,
          jwt:
            (u =
              (c = m.session) === null || c === void 0
                ? void 0
                : c.access_token) !== null && u !== void 0
              ? u
              : void 0,
        });
      });
      if (r) throw r;
      return (
        Vt() &&
          !(
            !((n = t.options) === null || n === void 0) && n.skipBrowserRedirect
          ) &&
          window.location.assign(o == null ? void 0 : o.url),
        {
          data: { provider: t.provider, url: o == null ? void 0 : o.url },
          error: null,
        }
      );
    } catch (o) {
      if (Z(o)) return { data: { provider: t.provider, url: null }, error: o };
      throw o;
    }
  }
  async unlinkIdentity(t) {
    try {
      return await this._useSession(async (n) => {
        var o, r;
        const { data: a, error: s } = n;
        if (s) throw s;
        return await oe(
          this.fetch,
          "DELETE",
          `${this.url}/user/identities/${t.identity_id}`,
          {
            headers: this.headers,
            jwt:
              (r =
                (o = a.session) === null || o === void 0
                  ? void 0
                  : o.access_token) !== null && r !== void 0
                ? r
                : void 0,
          },
        );
      });
    } catch (n) {
      if (Z(n)) return { data: null, error: n };
      throw n;
    }
  }
  async _refreshAccessToken(t) {
    const n = `#_refreshAccessToken(${t.substring(0, 5)}...)`;
    this._debug(n, "begin");
    try {
      const o = Date.now();
      return await BO(
        async (r) => (
          r > 0 && (await MO(200 * Math.pow(2, r - 1))),
          this._debug(n, "refreshing attempt", r),
          await oe(
            this.fetch,
            "POST",
            `${this.url}/token?grant_type=refresh_token`,
            { body: { refresh_token: t }, headers: this.headers, xform: _n },
          )
        ),
        (r, a) => {
          const s = 200 * Math.pow(2, r);
          return a && Uc(a) && Date.now() + s - o < qo;
        },
      );
    } catch (o) {
      if ((this._debug(n, "error", o), Z(o)))
        return { data: { session: null, user: null }, error: o };
      throw o;
    } finally {
      this._debug(n, "end");
    }
  }
  _isValidSession(t) {
    return (
      typeof t == "object" &&
      t !== null &&
      "access_token" in t &&
      "refresh_token" in t &&
      "expires_at" in t
    );
  }
  async _handleProviderSignIn(t, n) {
    const o = await this._getUrlForProvider(`${this.url}/authorize`, t, {
      redirectTo: n.redirectTo,
      scopes: n.scopes,
      queryParams: n.queryParams,
    });
    return (
      this._debug(
        "#_handleProviderSignIn()",
        "provider",
        t,
        "options",
        n,
        "url",
        o,
      ),
      Vt() && !n.skipBrowserRedirect && window.location.assign(o),
      { data: { provider: t, url: o }, error: null }
    );
  }
  async _recoverAndRefresh() {
    var t;
    const n = "#_recoverAndRefresh()";
    this._debug(n, "begin");
    try {
      const o = await Zs(this.storage, this.storageKey);
      if (
        (this._debug(n, "session from storage", o), !this._isValidSession(o))
      ) {
        this._debug(n, "session is not valid"),
          o !== null && (await this._removeSession());
        return;
      }
      const r =
        ((t = o.expires_at) !== null && t !== void 0 ? t : 1 / 0) * 1e3 -
          Date.now() <
        $c;
      if (
        (this._debug(
          n,
          `session has${r ? "" : " not"} expired with margin of ${$c}s`,
        ),
        r)
      ) {
        if (this.autoRefreshToken && o.refresh_token) {
          const { error: a } = await this._callRefreshToken(o.refresh_token);
          a &&
            (console.error(a),
            Uc(a) ||
              (this._debug(
                n,
                "refresh failed with a non-retryable error, removing the session",
                a,
              ),
              await this._removeSession()));
        }
      } else await this._notifyAllSubscribers("SIGNED_IN", o);
    } catch (o) {
      this._debug(n, "error", o), console.error(o);
      return;
    } finally {
      this._debug(n, "end");
    }
  }
  async _callRefreshToken(t) {
    var n, o;
    if (!t) throw new Pn();
    if (this.refreshingDeferred) return this.refreshingDeferred.promise;
    const r = `#_callRefreshToken(${t.substring(0, 5)}...)`;
    this._debug(r, "begin");
    try {
      this.refreshingDeferred = new Gl();
      const { data: a, error: s } = await this._refreshAccessToken(t);
      if (s) throw s;
      if (!a.session) throw new Pn();
      await this._saveSession(a.session),
        await this._notifyAllSubscribers("TOKEN_REFRESHED", a.session);
      const i = { session: a.session, error: null };
      return this.refreshingDeferred.resolve(i), i;
    } catch (a) {
      if ((this._debug(r, "error", a), Z(a))) {
        const s = { session: null, error: a };
        return (
          Uc(a) || (await this._removeSession()),
          (n = this.refreshingDeferred) === null ||
            n === void 0 ||
            n.resolve(s),
          s
        );
      }
      throw (
        ((o = this.refreshingDeferred) === null || o === void 0 || o.reject(a),
        a)
      );
    } finally {
      (this.refreshingDeferred = null), this._debug(r, "end");
    }
  }
  async _notifyAllSubscribers(t, n, o = !0) {
    const r = `#_notifyAllSubscribers(${t})`;
    this._debug(r, "begin", n, `broadcast = ${o}`);
    try {
      this.broadcastChannel &&
        o &&
        this.broadcastChannel.postMessage({ event: t, session: n });
      const a = [],
        s = Array.from(this.stateChangeEmitters.values()).map(async (i) => {
          try {
            await i.callback(t, n);
          } catch (l) {
            a.push(l);
          }
        });
      if ((await Promise.all(s), a.length > 0)) {
        for (let i = 0; i < a.length; i += 1) console.error(a[i]);
        throw a[0];
      }
    } finally {
      this._debug(r, "end");
    }
  }
  async _saveSession(t) {
    this._debug("#_saveSession()", t),
      (this.suppressGetSessionWarning = !0),
      await Yy(this.storage, this.storageKey, t);
  }
  async _removeSession() {
    this._debug("#_removeSession()"),
      await ei(this.storage, this.storageKey),
      await this._notifyAllSubscribers("SIGNED_OUT", null);
  }
  _removeVisibilityChangedCallback() {
    this._debug("#_removeVisibilityChangedCallback()");
    const t = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      t &&
        Vt() &&
        window != null &&
        window.removeEventListener &&
        window.removeEventListener("visibilitychange", t);
    } catch (n) {
      console.error("removing visibilitychange callback failed", n);
    }
  }
  async _startAutoRefresh() {
    await this._stopAutoRefresh(), this._debug("#_startAutoRefresh()");
    const t = setInterval(() => this._autoRefreshTokenTick(), qo);
    (this.autoRefreshTicker = t),
      t && typeof t == "object" && typeof t.unref == "function"
        ? t.unref()
        : typeof Deno < "u" &&
          typeof Deno.unrefTimer == "function" &&
          Deno.unrefTimer(t),
      setTimeout(async () => {
        await this.initializePromise, await this._autoRefreshTokenTick();
      }, 0);
  }
  async _stopAutoRefresh() {
    this._debug("#_stopAutoRefresh()");
    const t = this.autoRefreshTicker;
    (this.autoRefreshTicker = null), t && clearInterval(t);
  }
  async startAutoRefresh() {
    this._removeVisibilityChangedCallback(), await this._startAutoRefresh();
  }
  async stopAutoRefresh() {
    this._removeVisibilityChangedCallback(), await this._stopAutoRefresh();
  }
  async _autoRefreshTokenTick() {
    this._debug("#_autoRefreshTokenTick()", "begin");
    try {
      await this._acquireLock(0, async () => {
        try {
          const t = Date.now();
          try {
            return await this._useSession(async (n) => {
              const {
                data: { session: o },
              } = n;
              if (!o || !o.refresh_token || !o.expires_at) {
                this._debug("#_autoRefreshTokenTick()", "no session");
                return;
              }
              const r = Math.floor((o.expires_at * 1e3 - t) / qo);
              this._debug(
                "#_autoRefreshTokenTick()",
                `access token expires in ${r} ticks, a tick lasts ${qo}ms, refresh threshold is ${cu} ticks`,
              ),
                r <= cu && (await this._callRefreshToken(o.refresh_token));
            });
          } catch (n) {
            console.error(
              "Auto refresh tick failed with error. This is likely a transient error.",
              n,
            );
          }
        } finally {
          this._debug("#_autoRefreshTokenTick()", "end");
        }
      });
    } catch (t) {
      if (t.isAcquireTimeout || t instanceof Xy)
        this._debug("auto refresh token tick lock not available");
      else throw t;
    }
  }
  async _handleVisibilityChange() {
    if (
      (this._debug("#_handleVisibilityChange()"),
      !Vt() || !(window != null && window.addEventListener))
    )
      return this.autoRefreshToken && this.startAutoRefresh(), !1;
    try {
      (this.visibilityChangedCallback = async () =>
        await this._onVisibilityChanged(!1)),
        window == null ||
          window.addEventListener(
            "visibilitychange",
            this.visibilityChangedCallback,
          ),
        await this._onVisibilityChanged(!0);
    } catch (t) {
      console.error("_handleVisibilityChange", t);
    }
  }
  async _onVisibilityChanged(t) {
    const n = `#_onVisibilityChanged(${t})`;
    this._debug(n, "visibilityState", document.visibilityState),
      document.visibilityState === "visible"
        ? (this.autoRefreshToken && this._startAutoRefresh(),
          t ||
            (await this.initializePromise,
            await this._acquireLock(-1, async () => {
              if (document.visibilityState !== "visible") {
                this._debug(
                  n,
                  "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting",
                );
                return;
              }
              await this._recoverAndRefresh();
            })))
        : document.visibilityState === "hidden" &&
          this.autoRefreshToken &&
          this._stopAutoRefresh();
  }
  async _getUrlForProvider(t, n, o) {
    const r = [`provider=${encodeURIComponent(n)}`];
    if (
      (o != null &&
        o.redirectTo &&
        r.push(`redirect_to=${encodeURIComponent(o.redirectTo)}`),
      o != null && o.scopes && r.push(`scopes=${encodeURIComponent(o.scopes)}`),
      this.flowType === "pkce")
    ) {
      const [a, s] = await Ho(this.storage, this.storageKey),
        i = new URLSearchParams({
          code_challenge: `${encodeURIComponent(a)}`,
          code_challenge_method: `${encodeURIComponent(s)}`,
        });
      r.push(i.toString());
    }
    if (o != null && o.queryParams) {
      const a = new URLSearchParams(o.queryParams);
      r.push(a.toString());
    }
    return (
      o != null &&
        o.skipBrowserRedirect &&
        r.push(`skip_http_redirect=${o.skipBrowserRedirect}`),
      `${t}?${r.join("&")}`
    );
  }
  async _unenroll(t) {
    try {
      return await this._useSession(async (n) => {
        var o;
        const { data: r, error: a } = n;
        return a
          ? { data: null, error: a }
          : await oe(
              this.fetch,
              "DELETE",
              `${this.url}/factors/${t.factorId}`,
              {
                headers: this.headers,
                jwt:
                  (o = r == null ? void 0 : r.session) === null || o === void 0
                    ? void 0
                    : o.access_token,
              },
            );
      });
    } catch (n) {
      if (Z(n)) return { data: null, error: n };
      throw n;
    }
  }
  async _enroll(t) {
    try {
      return await this._useSession(async (n) => {
        var o, r;
        const { data: a, error: s } = n;
        if (s) return { data: null, error: s };
        const i = Object.assign(
            { friendly_name: t.friendlyName, factor_type: t.factorType },
            t.factorType === "phone"
              ? { phone: t.phone }
              : { issuer: t.issuer },
          ),
          { data: l, error: c } = await oe(
            this.fetch,
            "POST",
            `${this.url}/factors`,
            {
              body: i,
              headers: this.headers,
              jwt:
                (o = a == null ? void 0 : a.session) === null || o === void 0
                  ? void 0
                  : o.access_token,
            },
          );
        return c
          ? { data: null, error: c }
          : (t.factorType === "totp" &&
              !((r = l == null ? void 0 : l.totp) === null || r === void 0) &&
              r.qr_code &&
              (l.totp.qr_code = `data:image/svg+xml;utf-8,${l.totp.qr_code}`),
            { data: l, error: null });
      });
    } catch (n) {
      if (Z(n)) return { data: null, error: n };
      throw n;
    }
  }
  async _verify(t) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (n) => {
          var o;
          const { data: r, error: a } = n;
          if (a) return { data: null, error: a };
          const { data: s, error: i } = await oe(
            this.fetch,
            "POST",
            `${this.url}/factors/${t.factorId}/verify`,
            {
              body: { code: t.code, challenge_id: t.challengeId },
              headers: this.headers,
              jwt:
                (o = r == null ? void 0 : r.session) === null || o === void 0
                  ? void 0
                  : o.access_token,
            },
          );
          return i
            ? { data: null, error: i }
            : (await this._saveSession(
                Object.assign(
                  { expires_at: Math.round(Date.now() / 1e3) + s.expires_in },
                  s,
                ),
              ),
              await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", s),
              { data: s, error: i });
        });
      } catch (n) {
        if (Z(n)) return { data: null, error: n };
        throw n;
      }
    });
  }
  async _challenge(t) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (n) => {
          var o;
          const { data: r, error: a } = n;
          return a
            ? { data: null, error: a }
            : await oe(
                this.fetch,
                "POST",
                `${this.url}/factors/${t.factorId}/challenge`,
                {
                  body: { channel: t.channel },
                  headers: this.headers,
                  jwt:
                    (o = r == null ? void 0 : r.session) === null ||
                    o === void 0
                      ? void 0
                      : o.access_token,
                },
              );
        });
      } catch (n) {
        if (Z(n)) return { data: null, error: n };
        throw n;
      }
    });
  }
  async _challengeAndVerify(t) {
    const { data: n, error: o } = await this._challenge({
      factorId: t.factorId,
    });
    return o
      ? { data: null, error: o }
      : await this._verify({
          factorId: t.factorId,
          challengeId: n.id,
          code: t.code,
        });
  }
  async _listFactors() {
    const {
      data: { user: t },
      error: n,
    } = await this.getUser();
    if (n) return { data: null, error: n };
    const o = (t == null ? void 0 : t.factors) || [],
      r = o.filter((s) => s.factor_type === "totp" && s.status === "verified"),
      a = o.filter((s) => s.factor_type === "phone" && s.status === "verified");
    return { data: { all: o, totp: r, phone: a }, error: null };
  }
  async _getAuthenticatorAssuranceLevel() {
    return this._acquireLock(
      -1,
      async () =>
        await this._useSession(async (t) => {
          var n, o;
          const {
            data: { session: r },
            error: a,
          } = t;
          if (a) return { data: null, error: a };
          if (!r)
            return {
              data: {
                currentLevel: null,
                nextLevel: null,
                currentAuthenticationMethods: [],
              },
              error: null,
            };
          const { payload: s } = zc(r.access_token);
          let i = null;
          s.aal && (i = s.aal);
          let l = i;
          ((o =
            (n = r.user.factors) === null || n === void 0
              ? void 0
              : n.filter((m) => m.status === "verified")) !== null &&
          o !== void 0
            ? o
            : []
          ).length > 0 && (l = "aal2");
          const u = s.amr || [];
          return {
            data: {
              currentLevel: i,
              nextLevel: l,
              currentAuthenticationMethods: u,
            },
            error: null,
          };
        }),
    );
  }
  async fetchJwk(t, n = { keys: [] }) {
    let o = n.keys.find((s) => s.kid === t);
    if (
      o ||
      ((o = this.jwks.keys.find((s) => s.kid === t)),
      o && this.jwks_cached_at + SO > Date.now())
    )
      return o;
    const { data: r, error: a } = await oe(
      this.fetch,
      "GET",
      `${this.url}/.well-known/jwks.json`,
      { headers: this.headers },
    );
    if (a) throw a;
    if (!r.keys || r.keys.length === 0) throw new Ia("JWKS is empty");
    if (
      ((this.jwks = r),
      (this.jwks_cached_at = Date.now()),
      (o = r.keys.find((s) => s.kid === t)),
      !o)
    )
      throw new Ia("No matching signing key found in JWKS");
    return o;
  }
  async getClaims(t, n = { keys: [] }) {
    try {
      let o = t;
      if (!o) {
        const { data: h, error: g } = await this.getSession();
        if (g || !h.session) return { data: null, error: g };
        o = h.session.access_token;
      }
      const {
        header: r,
        payload: a,
        signature: s,
        raw: { header: i, payload: l },
      } = zc(o);
      if (
        (WO(a.exp),
        !r.kid ||
          r.alg === "HS256" ||
          !("crypto" in globalThis && "subtle" in globalThis.crypto))
      ) {
        const { error: h } = await this.getUser(o);
        if (h) throw h;
        return { data: { claims: a, header: r, signature: s }, error: null };
      }
      const c = GO(r.alg),
        u = await this.fetchJwk(r.kid, n),
        m = await crypto.subtle.importKey("jwk", u, c, !0, ["verify"]);
      if (!(await crypto.subtle.verify(c, m, s, OO(`${i}.${l}`))))
        throw new Ia("Invalid JWT signature");
      return { data: { claims: a, header: r, signature: s }, error: null };
    } catch (o) {
      if (Z(o)) return { data: null, error: o };
      throw o;
    }
  }
}
rs.nextInstanceID = 0;
const iI = rs;
class lI extends iI {
  constructor(t) {
    super(t);
  }
}
var cI = function (e, t, n, o) {
  function r(a) {
    return a instanceof n
      ? a
      : new n(function (s) {
          s(a);
        });
  }
  return new (n || (n = Promise))(function (a, s) {
    function i(u) {
      try {
        c(o.next(u));
      } catch (m) {
        s(m);
      }
    }
    function l(u) {
      try {
        c(o.throw(u));
      } catch (m) {
        s(m);
      }
    }
    function c(u) {
      u.done ? a(u.value) : r(u.value).then(i, l);
    }
    c((o = o.apply(e, t || [])).next());
  });
};
class dI {
  constructor(t, n, o) {
    var r, a, s;
    if (((this.supabaseUrl = t), (this.supabaseKey = n), !t))
      throw new Error("supabaseUrl is required.");
    if (!n) throw new Error("supabaseKey is required.");
    const i = hO(t);
    (this.realtimeUrl = `${i}/realtime/v1`.replace(/^http/i, "ws")),
      (this.authUrl = `${i}/auth/v1`),
      (this.storageUrl = `${i}/storage/v1`),
      (this.functionsUrl = `${i}/functions/v1`);
    const l = `sb-${new URL(this.authUrl).hostname.split(".")[0]}-auth-token`,
      c = {
        db: iO,
        realtime: cO,
        auth: Object.assign(Object.assign({}, lO), { storageKey: l }),
        global: sO,
      },
      u = vO(o ?? {}, c);
    (this.storageKey =
      (r = u.auth.storageKey) !== null && r !== void 0 ? r : ""),
      (this.headers = (a = u.global.headers) !== null && a !== void 0 ? a : {}),
      u.accessToken
        ? ((this.accessToken = u.accessToken),
          (this.auth = new Proxy(
            {},
            {
              get: (m, p) => {
                throw new Error(
                  `@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(p)} is not possible`,
                );
              },
            },
          )))
        : (this.auth = this._initSupabaseAuthClient(
            (s = u.auth) !== null && s !== void 0 ? s : {},
            this.headers,
            u.global.fetch,
          )),
      (this.fetch = pO(n, this._getAccessToken.bind(this), u.global.fetch)),
      (this.realtime = this._initRealtimeClient(
        Object.assign(
          {
            headers: this.headers,
            accessToken: this._getAccessToken.bind(this),
          },
          u.realtime,
        ),
      )),
      (this.rest = new DN(`${i}/rest/v1`, {
        headers: this.headers,
        schema: u.db.schema,
        fetch: this.fetch,
      })),
      u.accessToken || this._listenForAuthEvents();
  }
  get functions() {
    return new rN(this.functionsUrl, {
      headers: this.headers,
      customFetch: this.fetch,
    });
  }
  get storage() {
    return new oO(this.storageUrl, this.headers, this.fetch);
  }
  from(t) {
    return this.rest.from(t);
  }
  schema(t) {
    return this.rest.schema(t);
  }
  rpc(t, n = {}, o = {}) {
    return this.rest.rpc(t, n, o);
  }
  channel(t, n = { config: {} }) {
    return this.realtime.channel(t, n);
  }
  getChannels() {
    return this.realtime.getChannels();
  }
  removeChannel(t) {
    return this.realtime.removeChannel(t);
  }
  removeAllChannels() {
    return this.realtime.removeAllChannels();
  }
  _getAccessToken() {
    var t, n;
    return cI(this, void 0, void 0, function* () {
      if (this.accessToken) return yield this.accessToken();
      const { data: o } = yield this.auth.getSession();
      return (n =
        (t = o.session) === null || t === void 0 ? void 0 : t.access_token) !==
        null && n !== void 0
        ? n
        : null;
    });
  }
  _initSupabaseAuthClient(
    {
      autoRefreshToken: t,
      persistSession: n,
      detectSessionInUrl: o,
      storage: r,
      storageKey: a,
      flowType: s,
      lock: i,
      debug: l,
    },
    c,
    u,
  ) {
    const m = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`,
    };
    return new lI({
      url: this.authUrl,
      headers: Object.assign(Object.assign({}, m), c),
      storageKey: a,
      autoRefreshToken: t,
      persistSession: n,
      detectSessionInUrl: o,
      storage: r,
      flowType: s,
      lock: i,
      debug: l,
      fetch: u,
      hasCustomAuthorizationHeader: "Authorization" in this.headers,
    });
  }
  _initRealtimeClient(t) {
    return new VN(
      this.realtimeUrl,
      Object.assign(Object.assign({}, t), {
        params: Object.assign(
          { apikey: this.supabaseKey },
          t == null ? void 0 : t.params,
        ),
      }),
    );
  }
  _listenForAuthEvents() {
    return this.auth.onAuthStateChange((n, o) => {
      this._handleTokenChanged(
        n,
        "CLIENT",
        o == null ? void 0 : o.access_token,
      );
    });
  }
  _handleTokenChanged(t, n, o) {
    (t === "TOKEN_REFRESHED" || t === "SIGNED_IN") &&
    this.changedAccessToken !== o
      ? (this.changedAccessToken = o)
      : t === "SIGNED_OUT" &&
        (this.realtime.setAuth(),
        n == "STORAGE" && this.auth.signOut(),
        (this.changedAccessToken = void 0));
  }
}
const uI = (e, t, n) => new dI(e, t, n),
  mI = "https://qsxukllsvmrsawisrvds.supabase.co",
  pI =
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFzeHVrbGxzdm1yc2F3aXNydmRzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQyNjc3NTksImV4cCI6MjA1OTg0Mzc1OX0.0WL3PssjcJDk4gsVPOiE3pkcc0Lx-MF47HP3d3-16r0",
  pa = uI(mI, pI),
  Zy = f.createContext(void 0),
  fI = ({ children: e }) => {
    const [t, n] = f.useState(null),
      [o, r] = f.useState(null),
      [a, s] = f.useState(!0),
      i = Zg();
    f.useEffect(() => {
      const {
        data: { subscription: m },
      } = pa.auth.onAuthStateChange((p, h) => {
        r(h),
          n((h == null ? void 0 : h.user) ?? null),
          p === "SIGNED_IN" &&
            setTimeout(() => {
              po({
                title: "Logged in successfully",
                description: "Welcome back!",
              });
            }, 0),
          p === "SIGNED_OUT" &&
            setTimeout(() => {
              po({
                title: "Logged out",
                description: "You have been logged out successfully",
              });
            }, 0);
      });
      return (
        pa.auth.getSession().then(({ data: { session: p } }) => {
          r(p), n((p == null ? void 0 : p.user) ?? null), s(!1);
        }),
        () => {
          m.unsubscribe();
        }
      );
    }, []);
    const l = async (m, p, h, g) => {
        try {
          const { error: v } = await pa.auth.signUp({
            email: m,
            password: p,
            options: { data: { first_name: h || "", last_name: g || "" } },
          });
          if (v) throw v;
          po({
            title: "Account created",
            description: "Please check your email to confirm your account",
          }),
            i("/");
        } catch (v) {
          po({
            variant: "destructive",
            title: "Sign up failed",
            description:
              (v == null ? void 0 : v.message) ||
              "An error occurred during sign up",
          });
        }
      },
      c = async (m, p) => {
        try {
          const { error: h } = await pa.auth.signInWithPassword({
            email: m,
            password: p,
          });
          if (h) throw h;
          i("/");
        } catch (h) {
          po({
            variant: "destructive",
            title: "Login failed",
            description:
              (h == null ? void 0 : h.message) || "Invalid email or password",
          });
        }
      },
      u = async () => {
        try {
          const { error: m } = await pa.auth.signOut();
          if (m) throw m;
          i("/auth");
        } catch (m) {
          po({
            variant: "destructive",
            title: "Error signing out",
            description:
              (m == null ? void 0 : m.message) || "An error occurred",
          });
        }
      };
    return d.jsx(Zy.Provider, {
      "data-lov-id": "src/contexts/AuthContext.tsx:127:4",
      "data-lov-name": "AuthContext.Provider",
